@inproceedings{Begel:2019:BPE:3338704.3338706,
 author = {Begel, Andrew},
 title = {Best Practices for Engineering AI-infused Applications: Lessons Learned from Microsoft Teams},
 booktitle = {Proceedings of the Joint 7th International Workshop on Conducting Empirical Studies in Industry and 6th International Workshop on Software Engineering Research and Industrial Practice},
 series = {CESSER-IP '19},
 year = {2019},
 location = {Montreal, Quebec, Canada},
 pages = {1--1},
 numpages = {1},
 url = {https://doi.org/10.1109/CESSER-IP.2019.00008},
 doi = {10.1109/CESSER-IP.2019.00008},
 acmid = {3338706},
 publisher = {IEEE Press},
 address = {Piscataway, NJ, USA},
 keywords = {AI, industry practice, machine learning},
 yearMonth={2019-05},
 topicCode={hase talk},
abstract={Artificial intelligence and machine learning (AI/ML) are some of the newest trends to hit the software industry, compelling organizations to evolve their development processes to deliver novel products to their customers. In this talk, I describe a study in which we learned how Microsoft software teams develop AI/ML-based applications using a nine-stage AI workflow process informed by prior experiences developing early AI applications (e.g. search and NLP) and data science tools (e.g. application telemetry and bug reporting). Adapting this workflow into their pre-existing, well-evolved, Agile-like software engineering processes and job roles has resulted in a number of engineering challenges unique to the AI/ML domain, some universal to all teams, but others related to the amount of prior AI/ML experience and education the teams have. I tell you about some challenges and the solutions that teams have come up with. The lessons that Microsoft has learned can help other organizations embarking on their own path towards AI and ML.},
} 

@InBook{cambridge-handbook,
  author = 	 {Begel, Andrew and Ko, Andy},
  title = 	 {Cambridge Handbook of Computing Education Research},
  chapter = 	 {Learning Outside the Classroom},
  publisher = 	 {Cambridge University Press},
  year = 	 {2019},
  month={February},
  yearMonth={2019-02},
  isbn={9781108654555},
  doi={10.1017/9781108654555.027},
  topicCode={csed},
  abstract={The history of computing education research is replete with studies about learning in formal contexts, i.e. students learning from teachers in school classrooms. In this chapter, we explore other contexts in which learning about computing occurs, for example, through reading books, working through online tutorials, competing in hackathons, or asking and answering computing questions on a Q&A website. These activities are all examples of informal learningâ€”learning that is opportunistic, rather than planned; unstructured, rather than pedagogically created; self-directed, rather than teacher-centric; and integrated authentically into life activities (Marsick & Watkins, 2001), rather than taking place in a classroom environment. We collect and synthesize research about informal learning of computing and discuss open questions around where and how it occurs, and how to best support it.}
}

@inproceedings{autism-at-work-2:2019,
 author = {Annabi, Hala and Begel, Andrew and Fung, Lawrence},
 title={2019 2nd Research Workshop on Autism at Work},
 booktitle={2nd Annual Autism at Work Research Workshop},
 year={2019},
 yearMonth={2019-05},
 topicCode={accessibility},
 volume={},
 number={},
 pages={1-1},
 month={May},
 localurl={http://access-it.ischool.uw.edu/wordpress/2nd-annual-autism-at-work-research-workshop/},
 abtract={The Autism at Work Research Workshop brings together a small select group of leading scholars concerned with autism employment. Their work may relate to the preparation, recruitment, persistence, and advancement of individuals with autism in the workplace. Our objectives are to 1, build a community of scholars and practitioners concerned with issues related to the preparation and employment of individuals with autism; 2, provide a collaborative space for scholars to share their work and receive constructive feedback in order to advance autism employment research; and 3, further develop a research agenda to advance evidence-based practices to equitably include individuals with autism in the workplace.}
 }

@inproceedings{autism-at-work:2018,
 author = {Annabi, Hala and Begel, Andrew},
 title={2018 Research Workshop on Autism at Work},
 booktitle={Autism at Work Research Workshop},
 year={2018},
 yearMonth={2018-04},
 topicCode={accessibility},
 volume={},
 number={},
 pages={1-1},
 month={April},
 localurl={https://ischool.uw.edu/events/2018/04/autism-work-research-workshop},
 abtract={The Autism at Work Research Workshop brings together a small select group of leading scholars concerned with autism employment. Their work may relate to the preparation, recruitment, persistence, and advancement of individuals with autism in the workplace. Our objectives are to 1, build a community of scholars and practitioners concerned with issues related to the preparation and employment of individuals with autism; 2, develop a research agenda to advance evidence-based practices to equitably include individuals with autism in the workplace; and 3, identify types of interventions needed to create an inclusive workplace.}
 }


@inproceedings{Zolyomi:2019,
 author = {Zolyomi, Annuska and Begel, Andrew and Waldern, Jennifer Frances and Tang, John and Barnett, Mike and Cutrell, Edward and McDuff, Daniel and Andrist, Sean and Morris, Meredith Ringel},
 title = {Managing Stress: The Needs of Autistic Adults in Video Conferencing},
 booktitle = {Proceedings of the ACM 2012 Conference on Computer Supported Cooperative Work},
 series = {CSCW '19},
 year = {2019},
 month={November},
 yearMonth={2019-11},
 location = {Austin, Texas, USA},
 publisher = {ACM},
 address = {New York, NY, USA},
 topicCode = {accessibility},
 localurl={papers/video-calling-autism.pdf},

abstract={Video calling (VC) aims to create multi-modal, collaborative environments that are ``just like being there.'' However, we found
                  that autistic individuals, who exhibit atypical social and cognitive processing, may not share this goal. We interviewed
                  autistic adults about their perceptions of VC compared to other computer-mediated communications (CMC) and face-to-face
                  interactions. We developed a neurodiversity-sensitive model of CMC that describes how stressors such as sensory
                  sensitivities, cognitive load, and anxiety, contribute to their preferences for CMC channels. We learned that they apply
                  significant effort to construct coping strategies to support their sensory, cognitive, and social needs. These strategies
                  include moderating their sensory inputs, creating mental models of conversation partners, and attempting to mask their
                  autism by adopting neurotypical behaviors. Without effective strategies, interviewees experience more stress, have less
                  capacity to interpret verbal and non-verbal cues, and feel less empowered to participate. Our findings reveal critical
                  needs for autistic users. We suggest design opportunities to support their ability to comfortably use VC, and in doing so,
                  point the way towards making VC more comfortable for all.}
} 


@INPROCEEDINGS{emip-icse2019, 
author={A. Begel and J. Siegmund}, 
booktitle={2019 ACM 6th International Workshop on Eye Movements in Programming (EMIP)}, 
title={6th International Workshop on Eye Movements in Programming (EMIP 2019)}, 
year={2019},
yearMonth={2019-05},
topicCode={biometrics workshop},
volume={}, 
number={}, 
pages={1-1},  
abstract={Welcome to the 6th International Workshop on Eye Movements in Programming (EMIP), co-located with the 41st International Conference on Software Engineering (ICSE 2019) in Montreal, Canada.
The study of eye gaze data has great potential for research in computer programming, computing education, and software engineering practice. The Sixth International Workshop on Eye Movements in Programming (EMIP 2019) will focus on advancing the methodological, theoretical, and applied aspects of eye movements in programming. The goal of the workshop is to advance the methodology of using eye gaze tracking for programming, both theoretically and in applications. What can gaze behavior tell us about cognitive processes during programming? How can eye tracking help us to understand the role of human factors in software engineering?
The workshop will host a keynote by Dror Feitelson from the Hebrew University of Jerusalem, Israel. In his talk, Prof.\ Feitelson will survey achievements and suggest future directions about how eye tracking, especially regarding where programmers look, for how long, and how much mental effort they exert, provides crucial data on how reading and comprehending code differs from reading and comprehending regular text. Furthermore, this year's EMIP will have 7 presentations of accepted papers, mixed with interactive poster and hands-on demos. Thus, the entire workshop will have a focus on discussion and community building.}, 
keywords={}, 
ISSN={}, 
month={May},}

@inproceedings{Amershi:2019,
 author = {Amershi, Saleema and Begel, Andrew and Bird, Christian and DeLine, Robert and Gall, Harald and Kamar, Ece and Nagappan, Nachiappan and Nushi, Besmira and Zimmermann, Thomas},
 title = {Software Engineering for Machine Learning: A Case Study},
 booktitle = {Proceedings of the 41st International Conference on Software Engineering: Software Engineering in Practice},
 series = {ICSE-SEIP '19},
 yearMonth={2019-05},
 topicCode={hase},
 year = {2019},
 location = {Montreal, Quebec, Canada},
 pages = {1},
 numpages = {11},
 publisher = {ACM},
 address = {New York, NY, USA},
 localurl={papers/Software_Engineering_for_ML.pdf},
 keywords = {AI, software engineering, process, data},
 abstract ={Recent advances in machine learning have stimulated widespread interest within the Information Technology sector on integrating AI capabilities into software and services. This goal has forced organizations to evolve their development processes. We report on a study that we conducted on observing software teams at Microsoft as they develop AI-based applications.  We consider a nine-stage workflow process informed by prior experiences developing AI applications (e.g., search and NLP) and data science tools (e.g. application diagnostics and bug reporting). We found that various Microsoft teams have united this workflow into preexisting, well-evolved, Agile-like software engineering processes, providing insights about several essential engineering challenges that  organizations may face in creating large-scale AI solutions for the marketplace. We collected some best practices from Microsoft teams to address these challenges. In addition, we have identified three aspects of the AI domain that make it fundamentally different from prior software application domains: 1) discovering, managing, and versioning the data needed for machine learning applications is much more complex and difficult than other types of software engineering, 2) model customization and model reuse require very different skills than are typically found in software teams, and 3) AI components are more difficult to handle as distinct modules than traditional software components -- models may be "entangled" in complex ways and experience non-monotonic error behavior. We believe that the lessons learned by Microsoft teams will be valuable to other organizations.},
} 

@INPROCEEDINGS{semotion-icse2018, 
author={A. Begel and A. Serebrenik and D. Graziotin}, 
booktitle={2018 IEEE/ACM 3rd International Workshop on Emotion Awareness in Software Engineering (SEmotion)}, 
title={3rd International Workshop on Emotion Awareness in Software Engineering (SEmotion 2018)}, 
year={2018},
yearMonth={2018-05},
topicCode={biometrics workshop},
volume={}, 
number={}, 
pages={1-1},  
abstract={SEmotion 2018 Workshop Summary. Welcome to the 3rd International Workshop on Emotion Awareness in Software Engineering (SEmotion 2018)! This workshop, held at ICSE 2018, follows the second edition held at ICSE 2017. The workshop's aim is to create an international, sustainable forum for researchers and practitioners to meet, present, and discuss work on the role of affect and emotion in software engineering.
Affective computing is the study and development of systems and devices that can recognize, interpret, process, and simulate human affect, i.e. the experience of feeling or emotion. In the last decade, research has shown how affective states influence work performance and team collaboration. This also applies to software engineering, an inherently collaborative activity involving people in a broad range of collaborative tasks where personality, moods, and emotions play crucial roles.
To ensure the success of software engineering projects, stakeholders must experience positive affect, agree on display rules for emotions, and share mutual commitment towards project goals. By leveraging emotion awareness in software engineering, we can enhance development performance, improve software quality, help regulate the mood of a project team, and promote fruitful interactions between software engineering stakeholders.
SEmotion 2018 addresses the opportunities and challenges of employing affective computing in software engineering. First, we investigate the impact of affective states (emotions, moods, attitudes, personality traits, etc.) on individual and group performance, commitment, and collaboration in software engineering. Second, we foster discussion on issues posed by exploiting affective computing as a new method for empirical software engineering.}, 
keywords={}, 
ISSN={}, 
month={May},}

@inproceedings{Hilton:2018:SOD:3183519.3183527,
 author = {Hilton, Michael and Begel, Andrew},
 title = {A Study of the Organizational Dynamics of Software Teams},
 booktitle = {Proceedings of the 40th International Conference on Software Engineering: Software Engineering in Practice},
 series = {ICSE-SEIP '18},
 yearMonth={2018-05},
 topicCode={hase},
 year = {2018},
 isbn = {978-1-4503-5659-6},
 location = {Gothenburg, Sweden},
 pages = {191--200},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/3183519.3183527},
 doi = {10.1145/3183519.3183527},
 acmid = {3183527},
 publisher = {ACM},
 address = {New York, NY, USA},
 localurl={papers/A_Study_of_the_Organizational_Dynamics_of_Software_Teams.pdf},
 keywords = {employee turnover, organizational behavior, software engineers},
 abstract ={Large-scale software is developed by teams of engineers that work together. The teams' compositions change all the time, with engineers continuously leaving and joining. Learning about these organizational dynamics is vital to understanding how engineers acquire technical skills and business relationships throughout their career. In addition, since employee turnover can be costly to team morale and productivity, it is important for management to learn how to proactively guide the process. In this paper, we report on a study of a professional software development organization in which engineers switch teams frequently. We learned what causes engineers to consider leaving their teams, why they leave, how they learn about new teams, and how they decide which team to join. We also quantify the perceived costs and benefits of recent moves made by the engineers. In addition to reporting the answers to our research questions, we interpret our results to offer recommendations to engineers and their managers on how to ensure that both make better, happier team moves.},
 
} 

@inproceedings{Begel:2018:EMC:3216723.3216727,
 author = {Begel, Andrew and Vrzakova, Hana},
 title = {Eye Movements in Code Review},
 booktitle = {Proceedings of the Workshop on Eye Movements in Programming},
 series = {EMIP '18},
 year = {2018},
 isbn = {978-1-4503-5792-0},
 location = {Warsaw, Poland},
 pages = {5:1--5:5},
 articleno = {5},
 numpages = {5},
 url = {http://doi.acm.org/10.1145/3216723.3216727},
 doi = {10.1145/3216723.3216727},
 acmid = {3216727},
 publisher = {ACM},
 localurl={papers/eye-movements-code-review.pdf},
 address = {New York, NY, USA},
 keywords = {code review, eye tracking},
 abstract={In order to ensure sufficient quality, software engineers conduct code reviews to read over one another's code looking for errors that should be fixed before committing to their source code repositories. Many kinds of errors are spotted, from simple spelling mistakes and syntax errors, to architectural flaws that may span several files. However, we know little about how software developers read code when looking for defects. What kinds of code trigger engineers to check more deeply into suspected defects? How long do they take to verify whether a defect is really there? We conducted a study of 35 software engineers performing 40 code reviews while capturing their gaze with an eye tracker. We classified each code defect the developers found and captured the patterns of eye gazes used to deliberate about each one. We report how long it took to confirm defect suspicions for each type of defect and the fraction of time spent skimming the code vs. carefully reading it. This work provides a starting point for automating code reviews that could help engineers spend more time focusing on the difficult task of defect confirmation rather than the tedious task of defect discovery.},
} 



@INPROCEEDINGS{7961464, 
author={P. L. Li and A. J. Ko and A. Begel}, 
booktitle={2017 IEEE/ACM 10th International Workshop on Cooperative and Human Aspects of Software Engineering (CHASE)}, 
title={Cross-Disciplinary Perspectives on Collaborations with Software Engineers}, 
year={2017},
yearMonth={2017-05},
topicCode={hase},
volume={}, 
number={}, 
pages={2-8}, 
abstract={Software engineering teams are usually interdisciplinary, consisting of both software engineers and non-software-engineers. While numerous studies have examined the success and failure of software engineering efforts from the perspective of software engineers, little is known about perspectives of expert non-software-engineers. In this study, we interviewed 46 experts across 10 roles at Microsoft (artists, content developers, data scientists, design researchers, designers, electrical engineers, mechanical engineers, product planners, program managers, service engineers) about their collaborations-good and bad-with software engineers. Overall, our experts described great software engineers as masters of their own technical domain, open-minded to the input of others, proactively informing everyone, and seeing the big picture of how pieces fit together. We discuss implications of our findings for practitioners, educators, and researchers.}, 
keywords={software engineering;team working;collaborations;cross-disciplinary perspectives;educators;researchers;software engineering teams;software engineers;Collaboration;Encoding;Hardware;Interviews;Software;Software engineering;Team working;collaboration;interdisciplinary teams;software engineering expertise;team work}, 
doi={10.1109/CHASE.2017.3}, 
ISSN={}, 
month={May},}

@ARTICLE{8094304, 
author={E. Kalliamvakou and C. Bird and T. Zimmermann and A. Begel and R. DeLine and D. M. German}, 
journal={IEEE Transactions on Software Engineering}, 
title={What Makes a Great Manager of Software Engineers?}, 
year={2017},
yearMonth={2017-11},
topicCode={hase},
volume={PP},
localurl = {papers/great-manager.pdf},
number={99}, 
pages={1-1}, 
abstract={Having great managers is as critical to success as having a good team or organization. In general, a great manager is seen as fuelling the team they manage, enabling it to use its full potential. Though software engineering research studies factors that may affect the performance and productivity of software engineers and teams (like tools and skill), it has overlooked the software engineering manager. The software industry's growth and change in the last decades is creating a need for a domain-specific view of management. On the one hand, experts are questioning how the abundant work in management applies to software engineering. On the other hand, practitioners are looking to researchers for evidence-based guidance on how to manage software teams. We conducted a mixed methods empirical study of software engineering management at Microsoft to investigate what manager attributes developers and engineering managers perceive important and why. We present a conceptual framework of manager attributes, and find that technical skills are not the sign of greatness for an engineering manager. Through statistical analysis we identify how engineers and managers relate in their views, and how software engineering differs from other knowledge work groups in its perceptions about what makes great managers. We present strategies for putting the attributes to use, discuss implications for research and practice, and offer avenues for further work.}, 
keywords={Interviews;Knowledge engineering;Organizations;Productivity;Psychology;Software;Software engineering;empirical studies;software companies;software engineering management}, 
doi={10.1109/TSE.2017.2768368}, 
ISSN={0098-5589}, 
month={},}

@ARTICLE{8046093, 
author={M. Kim and T. Zimmermann and R. DeLine and A. Begel}, 
journal={IEEE Transactions on Software Engineering}, 
title={Data Scientists in Software Teams: State of the Art and Challenges}, 
year={2017},
yearMonth={2017-09},
volume={PP}, 
number={99}, 
pages={1-1},
localurl={papers/data-scientists.pdf},
topicCode={hase},
abstract={The demand for analyzing large scale telemetry, machine, and quality data is rapidly increasing in software industry. Data scientists are becoming popular within software teams, e.g., Facebook, LinkedIn and Microsoft are creating a new career path for data scientists. In this paper, we present a large-scale survey with 793 professional data scientists at Microsoft to understand their educational background, problem topics that they work on, tool usages, and activities. We cluster these data scientists based on the time spent for various activities and identify 9 distinct clusters of data scientists, and their corresponding characteristics. We also discuss the challenges that they face and the best practices they share with other data scientists. Our study finds several trends about data scientists in the software engineering context at Microsoft, and should inform managers on how to leverage data science capability effectively within their teams.}, 
keywords={Best practices;Data science;Interviews;Sociology;Software;Statistics;Tools;data science;development roles;industry;software engineering}, 
doi={10.1109/TSE.2017.2754374}, 
ISSN={0098-5589}, 
month={},}

@inproceedings{Siegmund:2017:MNE:3106237.3106268,
 author = {Siegmund, Janet and Peitek, Norman and Parnin, Chris and Apel, Sven and Hofmeister, Johannes and K\"{a}stner, Christian and Begel, Andrew and Bethmann, Anja and Brechmann, Andr{\'e}},
 title = {Measuring Neural Efficiency of Program Comprehension},
 booktitle = {Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering},
 series = {ESEC/FSE 2017},
 year = {2017},
 yearMonth={2017-05},
 topicCode={biometrics hase},
 isbn = {978-1-4503-5105-8},
 location = {Paderborn, Germany},
 pages = {140--150},
 numpages = {11},
 url = {http://doi.acm.org/10.1145/3106237.3106268},
 doi = {10.1145/3106237.3106268},
 localurl={papers/neural-efficiency.pdf},
 acmid = {3106268},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {functional magnetic resonance imaging, neural efficiency, program comprehension},
 abstract={Most modern software programs cannot be understood in their entirety by a single programmer. Instead, programmers must rely on a set of cognitive processes that aid in seeking, filtering, and shaping relevant information for a given programming task. Several theories have been proposed to explain these processes, such as "beacons," for locating relevant code, and "plans," for encoding cognitive models. However, these theories are decades old and lack validation with modern cognitive-neuroscience methods. In this paper, we report on a study using functional magnetic resonance imaging (fMRI) with 11 participants who performed program comprehension tasks. We manipulated experimental conditions related to beacons and layout to isolate specific cognitive processes related to bottom-up comprehension and comprehension based on semantic cues. We found evidence of semantic chunking during bottom-up comprehension and lower activation of brain areas during comprehension based on semantic cues, confirming that beacons ease comprehension.}
}

@inproceedings{DAngelo:2017:ICP:3025453.3025573,
 author = {D'Angelo, Sarah and Begel, Andrew},
 title = {Improving Communication Between Pair Programmers Using Shared Gaze Awareness},
 booktitle = {Proceedings of the 2017 CHI Conference on Human Factors in Computing Systems},
 series = {CHI '17},
 yearMonth={2017-04},
 year = {2017},
 topicCode={biometrics hase},
 isbn = {978-1-4503-4655-9},
 location = {Denver, Colorado, USA},
 pages = {6245--6290},
 numpages = {46},
 url = {http://doi.acm.org/10.1145/3025453.3025573},
 doi = {10.1145/3025453.3025573},
 localurl={eye-gaze-pair-programming.pdf},
 acmid = {3025573},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {collaboration, eye-tracking, pair programming},
 abstract={Remote collaboration can be more difficult than collocated collaboration for a number of reasons, including the inability to easily determine what your collaborator is looking at. This impedes a pair's ability to efficiently communicate about on-screen locations and makes synchronous coordination difficult. We designed a novel gaze visualization for remote pair programmers which shows where in the code their partner is currently looking, and changes color when they are looking at the same thing. Our design is unobtrusive, and transparently depicts the imprecision inherent in eye tracking technology. We evaluated our design with an experiment in which pair programmers worked remotely on code refactoring tasks. Our results show that with the visualization, pairs spent a greater proportion of their time concurrently looking at the same code locations. Pairs communicated using a larger ratio of implicit to explicit references, and were faster and more successful at responding to those references.},
} 

@inproceedings{morris-assets15,
 author = {Morris, Meredith Ringel and Begel, Andrew and Wiedermann, Ben},
 title = {Understanding the Challenges Faced by Neurodiverse Software Engineering Employees: Towards a More Inclusive and Productive Technical Workforce},
 booktitle = {Proceedings of the 17th International ACM SIGACCESS Conference on Computers \&\#38; Accessibility},
 series = {ASSETS '15},
 year = {2015},
 yearMonth={2015-10},
 isbn = {978-1-4503-3400-6},
 location = {Lisbon, Portugal},
 pages = {173--184},
 numpages = {12},
 topicCode={hase},
 url = {http://doi.acm.org/10.1145/2700648.2809841},
 doi = {10.1145/2700648.2809841},
 acmid = {2809841},
 publisher = {ACM},
 address = {New York, NY, USA},
 localurl={papers/neurodiverse_tech_employees_assets2015.pdf},
 keywords = {attention deficit hyperactivity disorder, autism spectrum disorder, neurodiversity, software development},
 abstract={Technology workers are often stereotyped as being socially awkward or having difficulty communicating, often with humorous intent; however, for many technology workers with atypical cognitive profiles, such issues are no laughing matter. In this paper, we explore the hidden lives of neurodiverse technology workers, e.g., those with autism spectrum disorder (ASD), attention deficit hyperactivity disorder (ADHD), and/or other learning disabilities, such as dyslexia. We present findings from interviews with 10 neurodiverse technology workers, identifying the challenges that impede these employees from fully realizing their potential in the workplace. Based on the interview findings, we developed a survey that was taken by 846 engineers at a large software company. In this paper, we reflect on the differences between the neurotypical (N = 781) and neurodiverse (N = 59) respondents. Technology companies struggle to attract, develop, and retain talented software developers; our findings offer insight into how employers can better support the needs of this important worker constituency.}
} 

@inproceedings{kim-icse16,
 author = {Kim, Miryung and Zimmermann, Thomas and DeLine, Robert and Begel, Andrew},
 title = {The Emerging Role of Data Scientists on Software Development Teams},
 booktitle = {Proceedings of the 38th International Conference on Software Engineering},
 series = {ICSE '16},
 year = {2016},
 yearMonth={2016-05},
 isbn = {978-1-4503-3900-1},
 location = {Austin, Texas},
 pages = {96--107},
 numpages = {12},
 topicCode={hase},
 url = {http://doi.acm.org/10.1145/2884781.2884783},
 doi = {10.1145/2884781.2884783},
 acmid = {2884783},
 publisher = {ACM},
 address = {New York, NY, USA},
 localurl={papers/emerging-role-of-data-scientists.pdf},
 abstract={Creating and running software produces large amounts of raw data about the development process and the customer usage, which can be turned into actionable insight with the help of skilled data scientists. Unfortunately, data scientists with the analytical and software engineering skills to analyze these large data sets have been hard to come by; only recently have software companies started to develop competencies in software-oriented data analytics. To understand this emerging role, we interviewed data scientists across several product groups at Microsoft. In this paper, we describe their education and training background, their missions in software engineering contexts, and the type of problems on which they work. We identify five distinct working styles of data scientists: (1) Insight Providers, who work with engineers to collect the data needed to inform decisions that managers make; (2) Modeling Specialists, who use their machine learning expertise to build predictive models; (3) Platform Builders, who create data platforms, balancing both engineering and data analysis concerns; (4) Polymaths, who do all data science activities themselves; and (5) Team Leaders, who run teams of data scientists and spread best practices. We further describe a set of strategies that they employ to increase the impact and actionability of their work.},
} 

@INPROCEEDINGS{7961883, 
author={N. Novielli and A. Begel and W. Maalej}, 
booktitle={2017 IEEE/ACM 2nd International Workshop on Emotion Awareness in Software Engineering (SEmotion)}, 
title={2nd International Workshop on Emotion Awareness in Software Engineering (SEmotion 2017)}, 
year={2017},
yearMonth={2017-05},
topicCode={biometrics workshop},
volume={}, 
number={}, 
pages={1-1},  
abstract={SEmotion 2017 Workshop Summary. Affective computing is the study and development of systems and devices that can recognize, interpret, process, and simulate human affect, i.e. the experience of feelings or emotions. Over the past decade, research has shown the impact of affective states on work performance and team collaboration. Personality, moods, and emotions play crucial roles in software engineering because it involves people in a broad range of activities. For successful software engineering projects, stakeholders need to experience positive affect (such as trust or appreciation), to agree on display rules for emotions, and to hold mutual commitment to project goals. Recently, researchers have started to study the role of affective computing and affective states in software engineering, but contributions to this area are presented and discussed in too many different conferences and workshops. This workshop follows up from the first edition held at ICSE 2016. Its goal is to consolidate research and create an international, sustainable forum for researchers and practitioners interested in the role of affect in software engineering to meet, present, and discuss their work-in-progress. High-quality contributions related to empirical studies, theoretical models, and tools for supporting emotion awareness in software engineering are invited to the workshop, both from academia and industry.}, 
keywords={}, 
doi={10.1109/SEmotion.2017.16}, 
ISSN={}, 
month={May},}

@inproceedings{parnin-semotion16-handson,
 author = {Parnin, Chris and Begel, Andrew},
 title = {Hands-on Sensors 101: Invited Session},
 booktitle = {Proceedings of the 1st International Workshop on Emotion Awareness in Software Engineering},
 series = {SEmotion '16},
 year = {2016},
 yearMonth={2016-05},
 topicCode={biometrics},
 isbn = {978-1-4503-4169-1},
 location = {Austin, Texas},
 pages = {28--29},
 numpages = {2},
 url = {http://doi.acm.org/10.1145/2897000.2897009},
 doi = {10.1145/2897000.2897009},
 acmid = {2897009},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {biometrics, eye tracking, psycho-physiological, training},
 abstract={This will be a one hour long practicum where attendees, guided by experts, will try out biometric sensors and equipment, including eye trackers, electrodermal activity sensors, and heart rate monitors. Attendees will write code to collect data from a sensor and analyze it to compute operationalized metrics like cognitive load. These will be applied to a simple research experiment. Attendees will gain the basic knowledge needed to engage in research with psycho-physiological sensors.},
} 




@inproceedings{begel-semotion16-talk,
 author = {Begel, Andrew},
 title = {Fun with Software Developers and Biometrics: Invited Talk},
 booktitle = {Proceedings of the 1st International Workshop on Emotion Awareness in Software Engineering},
 series = {SEmotion '16},
 year = {2016},
 yearMonth={2016-05},
 isbn = {978-1-4503-4169-1},
 location = {Austin, Texas},
 pages = {1--2},
 numpages = {2},
 topicCode={biometrics talk
 url = {http://doi.acm.org/10.1145/2897000.2897007},
 doi = {10.1145/2897000.2897007},
 acmid = {2897007},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {biometrics, sensors, software engineering},
 abstract={The use of low-cost, widely available, biometric sensors has skyrocketed over the past few years, enabling anyone to measure how their physiological signals change as they go about their daily lives. We use these sensors to understand software development activities, however, their use is not straightforward, nor is it easy. In this paper, we introduce some common sensors, along with some difficulties we encountered in using them in our experiments as well as how we worked past them. We call on everyone in our community to share best practices in sensor application and analysis in order to enable our field to grow as quickly as possible while producing robust, reliable results.},
} 

@inproceedings{chase2015,
 author = {Begel, Andrew and Prikladnicki, Rafael and Dittrich, Yvonne and de Souza, Cleidson R. B. and Sarma, Anita and Athavale, Sandeep},
 title = {8th International Workshop on Cooperative and Human Aspects of Software Engineering (CHASE 2015)},
 booktitle = {Proceedings of the 37th International Conference on Software Engineering},
 year = {2015},
 month={May},
 yearMonth={2015-05},
 pages = {969--970},
 location = {Florence, Italy},
 publisher = {IEEE Press},
 address = {Piscataway, NJ, USA},
 topicCode={hase workshop},
 doi={10.1109/ICSE.2015.309},
 abstract={Software is created for and with a wide range of
                  stakeholders, from customers to management, from
                  value-added providers to customer service
                  personnel. These stakeholders work with teams of
                  software engineers to develop and evolve software
                  systems that support their activities. All of these
                  people and their interactions are central to
                  software development. Thus, it is crucial to
                  investigate the dynamic and frequently changing
                  Cooperative and Human Aspects of Software
                  Engineering (CHASE), both before and after
                  deployment, in order to understand current software
                  practices, processes, and tools. In turn, this
                  enables us to design tools and support mechanisms
                  that improve software creation, software
                  maintenance, and customer communication.
                  Researchers and practitioners have long recognized
                  the need to investigate these aspects, however,
                  their articles are scattered across conferences and
                  communities. This workshop will provide a unified
                  forum for discussing high quality research studies,
                  models, methods, and tools for human and cooperative
                  aspects of software engineering. This will be the
                  8th in a series of workshops, which continue to be a
                  meeting place for the academic, industrial, and
                  practitioner communities interested in this area,
                  and will give opportunities to present and discuss
                  works-in-progress.  },
 }

@inproceedings{busjahn-eyemovements,
 author = {Busjahn, Teresa and Bednarik, Roman and Begel, Andrew and Crosby, Martha and Paterson, James H. and Schulte, Carsten and Sharif, Bonita and Tamm, Sascha},
 title = {Eye movements in code reading: relaxing the linear order},
 booktitle = {Proceedings of the 2015 IEEE 23rd International Conference on Program Comprehension},
 year = {2015},
 month= {May},
 yearMonth={2015-05},
 pages = {255--265},
 location = {Florence, Italy},
 publisher = {IEEE Press},
 address = {Piscataway, NJ, USA},
 topicCode={biometrics csed},
 doi={10.1109/ICPC.2015.36},
 abstract={Code reading is an important skill in programming. Inspired
                  by the linearity that people exhibit while natural
                  language text reading, we designed local and global
                  gaze-based measures to characterize linearity
                  (left-to-right and top-to-bottom) in reading source
                  code. Unlike natural language text, source code is
                  executable and requires a specific reading
                  approach. To validate these measures, we compared
                  the eye movements of novice and expert programmers
                  who were asked to read and comprehend short snippets
                  of natural language text and Java programs.  Our
                  results show that novices read source code less
                  linearly than natural language text. Moreover,
                  experts read code less linearly than novices. These
                  findings indicate that there are specific
                  differences between reading natural language and
                  source code, and suggest that non-linear reading
                  skills increase with expertise. We discuss the
                  implications for practitioners and educators.  },
}



@InProceedings{begel-eye-workshop,
  author = 	 {Begel, Andrew},
  title = 	 {Analyzing Programming Tasks},
  booktitle =	 {Proceedings of the First International Workshop for Eye Movements in Programming Education: Analyzing the Expert's Gaze},
  year =	 {2013},
  month= {November},
  yearMonth={2013-11},
  location={Joensuu, Finland},
  editor =	 {Bednarik, Roman and Busjahn, Teresa and Schulte, Carsten},
  number =	 {18},
  series =	 {Reports and Studies in Forestry and Natural Sciences},
  pages =	 {4--4},
  organization = {University of Eastern Finland},
  localurl = {papers/eye-tracking-workshop-koli-2013.pdf},
  url={http://epublications.uef.fi/pub/urn_isbn_978-952-61-1539-9/},
  topicCode={biometrics csed},
  abstract={In this position paper, I first describe the eyetracking patterns
of the two participant videos I watched and coded.
Next, I reflect on the methods and validity of manual coding
and interpretation, and finally, I add my own thoughts on
the utility of eyetracking data for understanding and helping
programmers create and maintain software.},
 
}

@inproceedings{Busjahn:2014:ETC:2632320.2632344,
 author = {Busjahn, Teresa and Schulte, Carsten and Sharif, Bonita and Simon and Begel, Andrew and Hansen, Michael and Bednarik, Roman and Orlov, Paul and Ihantola, Petri and Shchekotova, Galina and Antropova, Maria},
 title = {Eye Tracking in Computing Education},
 booktitle = {Proceedings of the Tenth Annual Conference on International Computing Education Research},
 series = {ICER '14},
 year = {2014},
 month={August},
 yearMonth={2014-08},
 isbn = {978-1-4503-2755-8},
 location = {Glasgow, Scotland, United Kingdom},
 pages = {3--10},
 numpages = {8},
 localurl={papers/icer818-busjahn.pdf}
 doi = {10.1145/2632320.2632344},
 acmid = {2632344},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {code reading, computing education, cs ed research, empirical research, eye tracking, gaze analysis, program comprehension, programming education, teaching programming},
topicCode = {biometrics csed},
abstract={The methodology of eye tracking has been gradually making
                  its way into various fields of science, assisted by
                  the diminishing cost of the associated
                  technology. In an international collaboration to
                  open up the prospect of eye movement research for
                  programming educators, we present a case study on
                  program comprehension and preliminary analyses
                  together with some useful tools.  The main
                  contributions of this paper are (1) an introduction
                  to eye tracking to study programmers; (2) an
                  approach that can help elucidate how novices learn
                  to read and understand programs and to identify
                  improvements to teaching and tools; (3) a
                  consideration of data analysis methods and
                  challenges, along with tools to address them; and
                  (4) some larger computing education questions that
                  can be addressed (or revisited) in the context of
                  eye tracking.}
} 

@inproceedings{Begel:2014:ATQ:2568225.2568233,
 author = {Begel, Andrew and Zimmermann, Thomas},
 title = {Analyze This! 145 Questions for Data Scientists in Software Engineering},
 booktitle = {Proceedings of the 36th International Conference on Software Engineering},
 series = {ICSE 2014},
 year = {2014},
 month={June},
 yearMonth={2014-06},
 isbn = {978-1-4503-2756-5},
 location = {Hyderabad, India},
 pages = {12--23},
 numpages = {12},
 doi = {10.1145/2568225.2568233},
 acmid = {2568233},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Analytics, Data Science, Software Engineering},
topicCode = {hase},
 localurl={papers/begel-icse-2014.pdf},
abstract={In this paper, we present the results from two surveys
                  related to data science applied to software
                  engineering. The first survey solicited questions
                  that software engineers would like data scientists
                  to investigate about software, about software
                  processes and practices, and about software
                  engineers. Our analyses resulted in a list of 145
                  questions grouped into 12 categories. The second
                  survey asked a different pool of software engineers
                  to rate these 145 questions and identify the most
                  important ones to work on first. Respondents favored
                  questions that focus on how customers typically use
                  their applications. We also saw opposition to
                  questions that assess the performance of individual
                  employees or compare them with one another. Our
                  categorization and catalog of 145 questions can help
                  researchers, practitioners, and educators to more
                  easily focus their efforts on topics that are
                  important to the software industry. }
} 


@inproceedings{Fritz:2014:UPM:2568225.2568266,
 author = {Fritz, Thomas and Begel, Andrew and M\"{u}ller, Sebastian C. and Yigit-Elliott, Serap and Z\"{u}ger, Manuela},
 title = {Using Psycho-physiological Measures to Assess Task Difficulty in Software Development},
 booktitle = {Proceedings of the 36th International Conference on Software Engineering},
 series = {ICSE 2014},
 year = {2014},
 yearMonth={2014-06},
 isbn = {978-1-4503-2756-5},
 location = {Hyderabad, India},
 pages = {402-413},
 numpages = {12},
 doi = {10.1145/2568225.2568266},
 acmid = {2568266},
 publisher = {ACM},
 month={June},
 address = {New York, NY, USA},
 keywords = {psycho-physiological, study, task difficulty},
topicCode = {biometrics},
 localurl={papers/biometricSensors_Submitted-07-03-14.pdf},
abstract={Software developers make programming mistakes that cause
                  serious bugs for their customers. Existing work to
                  detect problematic software focuses mainly on post
                  hoc identification of correlations between bug fixes
                  and code. We propose a new approach to address this
                  problem --- detect when software developers are
                  experiencing difficulty while they work on their
                  programming tasks, and stop them before they can
                  introduce bugs into the code.  In this paper, we
                  investigate a novel approach to classify the
                  difficulty of code comprehension tasks using data
                  from psycho-physiological sensors. We present the
                  results of a study we conducted with 15 professional
                  programmers to see how well an eye-tracker, an
                  electrodermal activity sensor, and an
                  electroencephalography sensor could be used to
                  predict whether developers would find a task to be
                  difficult. We can predict nominal task difficulty
                  (easy/difficult) for a new developer with 64.99\%
                  precision and 64.58\% recall, and for a new task with
                  84.38\% precision and 69.79\% recall. We can improve
                  the Naive Bayes classifier's performance if we
                  trained it on just the eye-tracking data over the
                  entire dataset, or by using a sliding window data
                  collection schema with a 55 second time window. Our
                  work brings the community closer to a viable and
                  reliable measure of task difficulty that could power
                  the next generation of programming support tools.}


} 



@inproceedings{Begel:2013:IWU:2486788.2487083,
 author = {Begel, Andrew and Sadowski, Caitlin},
 title = {2nd International Workshop on User Evaluations for Software Engineering Researchers},
 booktitle = {Proceedings of the 2013 International Conference on Software Engineering},
 series = {ICSE '13},
 year = {2013},
 month={May},
 yearMonth={2013-05},
 isbn = {978-1-4673-3076-3},
 location = {San Francisco, CA, USA},
 pages = {1558--1559},
 numpages = {2},
 url = {http://dl.acm.org/citation.cfm?id=2486788.2487083},
 acmid = {2487083},
 publisher = {IEEE Press},
 address = {Piscataway, NJ, USA},
topicCode = {workshop hase},
 localurl={http://sites.google.com/site/user2013workshop},
abstract={We have met many software engineering researchers who would
                  like to evaluate a tool or system they developed
                  with real users, but do not know how to begin. In
                  this second iteration of the USER workshop,
                  attendees will collaboratively design, develop, and
                  pilot plans for conducting user evaluations of their
                  own tools and/or software engineering research
                  projects. Attendees will gain practical experience
                  with various user evaluation methods through
                  scaffolded group exercises, panel discussions, and
                  mentoring by a panel of user-focused software
                  engineering researchers. Together, we will establish
                  a community of like-minded researchers and
                  developers to help one another improve our research
                  and practice through user evaluation. }
} 

@proceedings{Begel:2012:2667089,
 title = {First International Workshop on User Evaluation for Software Engineering Researchers},
 year = {2012},
 isbn = {978-1-4673-1859-4},
 location = {Zurich, Switzerland},
 note = {IEEE Catalog Number: CFP1205T-ART},
 publisher = {IEEE Press},
 address = {Piscataway, NJ, USA},
 month={May},
 topicCode={workshop hase},
 author = {Begel, Andrew and Sadowski, Caitlin},
 yearMonth={2012-05},
 url = {http://dl.acm.org/citation.cfm?id=2667089},
 publisher = {IEEE Press},
 address = {Piscataway, NJ, USA},
 topicCode = {workshop hase},
 localurl={http://user.supertriceratops.com/}
abstract={We have met many software engineering researchers
who would like to evaluate a tool or system they developed with
real users, but do not know how to begin. In this workshop,
participants will interactively learn suitable usability methods
through scaffolded group exercises, collaboratively develop and
test plans for evaluating their projects, and construct a support
network of like-minded researchers to help them achieve their
goals.}
} 





@inproceedings{Bettenburg:2013:DSS:2486788.2486960,
 author = {Bettenburg, Nicolas and Begel, Andrew},
 title = {Deciphering the Story of Software Development Through Frequent Pattern Mining},
 booktitle = {Proceedings of the 2013 International Conference on Software Engineering},
 series = {ICSE '13},
 year = {2013},
 month={May},
 yearMonth={2013-05},
 isbn = {978-1-4673-3076-3},
 location = {San Francisco, CA, USA},
 pages = {1197--1200},
 numpages = {4},
 url = {http://dl.acm.org/citation.cfm?id=2486788.2486960},
 acmid = {2486960},
 publisher = {IEEE Press},
 address = {Piscataway, NJ, USA},
topicCode = {hase},
 localurl={papers/decipher-icse13-nier.pdf},
abstract={Software teams record their work progress in task
                  repositories which often require them to encode
                  their activities in a set of edits to field values
                  in a form-based user interface. When others read the
                  tasks, they must decode the schema used to write the
                  activities down. We interviewed four software teams
                  and found out how they used the task repository
                  fields to record their work activities. However, we
                  also found that they had trouble interpreting task
                  revisions that encoded for multiple activities at
                  the same time. To assist engineers in decoding
                  tasks, we developed a scalable method based on
                  frequent pattern mining to identify patterns of
                  frequently co-edited fields that each represent a
                  conceptual work activity. We applied our method to
                  our two years of our interviewee's task repositories
                  and were able to abstract 83,000 field changes into
                  just 27 patterns that cover 95\% of the task
                  revisions. We used the 27 patterns to render the
                  teams' tasks in web-based English newsfeeds and
                  evaluated them with the product teams. The team
                  agreed with most of our patterns and English
                  interpretations, but outlined a number of
                  improvements that we will incorporate into future
                  work. }
} 

@inproceedings{Guzzi:2012:FCE:2337223.2337420,
 author = {Guzzi, Anja and Begel, Andrew},
 title = {Facilitating Communication Between Engineers with CARES. Demo.},
 booktitle = {Proceedings of the 34th International Conference on Software Engineering},
 series = {ICSE '12},
 year = {2012},
 month={June},
 yearMonth={2012-06},
 isbn = {978-1-4673-1067-3},
 location = {Zurich, Switzerland},
 pages = {1367--1370},
 numpages = {4},
 url = {http://dl.acm.org/citation.cfm?id=2337223.2337420},
localurl={papers/cares-icsedemo.pdf},
 acmid = {2337420},
 publisher = {IEEE Press},
 address = {Piscataway, NJ, USA},
topicCode = {hase tool},
abstract={When software developers need to exchange information or
                  coordinate work with colleagues on other teams, they
                  are often faced with the challenge of finding the
                  right person to communicate with. In this paper, we
                  present our tool, called CARES (Colleagues and
                  Relevant Engineers' Support), which is an integrated
                  development environment-based (IDE) tool that
                  enables engineers to easily discover and communicate
                  with the people who have contributed to the source
                  code. CARES has been deployed to 30 professional
                  developers, and we interviewed 8 of them after 3
                  weeks of evaluation. They reported that CARES helped
                  them to more quickly find, choose, and initiate
                  contact with the most relevant and expedient person
                  who could address their needs. }
} 

@inproceedings{Grubb:2012:PII:2145204.2145403,
 author = {Grubb, Alicia M. and Begel, Andrew},
 title = {On the Perceived Interdependence and Information Sharing Inhibitions of Enterprise Software Engineers},
 booktitle = {Proceedings of the ACM 2012 Conference on Computer Supported Cooperative Work},
 series = {CSCW '12},
 year = {2012},
 month={February},
 yearMonth={2012-02},
 isbn = {978-1-4503-1086-4},
 location = {Seattle, Washington, USA},
 pages = {1337--1346},
 numpages = {10},
 doi = {10.1145/2145204.2145403},
 acmid = {2145403},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {awareness, communication, coordination, enterprise software development},
topicCode = {hase socialmedia},
 localurl={papers/inhibitions-cscw12.pdf},
abstract={Software teams often have trouble coordinating shared work
                  due to poor communication practices. We surveyed
                  software engineers (N=989) at Microsoft to
                  investigate three rarely explored aspects of
                  coordination: (1) how an engineer's perception of
                  dependence is predicted by his organizational
                  characteristics, (2) how this perception differs
                  when the dependence varies by the kinds of shared
                  work artifacts, and (3) how the work group range
                  affects the likelihood that an engineer will share
                  information about work artifacts with another. Our
                  results indicate that engineers tailor their
                  communications about shared work for each group of
                  intended recipients. This suggests that many
                  existing coordination tools that rely on automatic
                  mining and visualization of engineering activities
                  have prevented senders from controlling the
                  distribution of information about their work, and
                  may have overestimated the receivers' abilities to
                  comprehend it.}
} 

@inproceedings{Begel:2012:FCS:2141512.2141522,
 author = {Begel, Andrew and Herbsleb, James D. and Storey, Margaret-Anne},
 title = {The Future of Collaborative Software Development},
 booktitle = {Proceedings of the ACM 2012 Conference on Computer Supported Cooperative Work Companion},
 series = {CSCW '12},
 year = {2012},
 month={February},
 yearMonth={2012-02},
 isbn = {978-1-4503-1051-2},
 location = {Seattle, Washington, USA},
 pages = {17--18},
 numpages = {2},
 doi = {10.1145/2141512.2141522},
 acmid = {2141522},
 publisher = {ACM},
url={http://research.microsoft.com/en-us/events/futurecsd/},
 address = {New York, NY, USA},
 keywords = {crowdsourcing, social media, software development},
topicCode = {workshop socialmedia hase},
 localurl={papers/futurecsd-cscw12.pdf},
abstract={Software development organizations are changing from
                  traditional enterprise or open source teams to
                  decentralized, inter-reliant, multi-scale ecosystems
                  of software developers. This transformation presents
                  novel challenges and opportunities to those seeking
                  to understand, evaluate, support, and influence
                  these organizations. The goals of this workshop are
                  to bring together researchers who are interested in
                  the evolution of software development organizations,
                  highlighting the role of collaboration technology,
                  such as crowdsourcing, social media, software
                  hosting, and application marketplace services, in
                  shaping organizational transformation, and
                  coordinating future efforts.}
} 


@article{Treude:2011:WRW:2020976.2020977,
 author = {Treude, Christoph and Storey, Margaret-Anne and van Deursen, Arie and Begel, Andrew and Black, Sue},
 title = {Workshop Report from Web2SE 2011: 2nd International Workshop on Web 2.0 for Software Engineering},
 journal = {SIGSOFT Software Engineering Notes},
 issue_date = {September 2011},
 volume = {36},
 number = {5},
 month = {September},
 yearMonth={2011-09},
 year = {2011},
 issn = {0163-5948},
 pages = {24--29},
 numpages = {6},
 doi = {10.1145/2020976.2020977},
 acmid = {2020977},
 publisher = {ACM},
 address = {New York, NY, USA},
topicCode = {workshop hase socialmedia},
 localurl={papers/web2se-report11.pdf},
abstract={Web 2.0 technologies, such as wikis, blogs, tags and feeds,
                  have been adopted and adapted by software
                  engineers. With the annual Web2SE workshop, we
                  provide a venue for research on Web 2.0 for software
                  engineering by highlighting state-of-the-art work,
                  identifying current research areas, discussing
                  implications of Web 2.0 on software engineering, and
                  outlining the risks and challenges for
                  researchers. This report highlights the paper and
                  tool presentations, and the discussions among
                  participants at Web2SE 2011 in Honolulu, as well as
                  future directions of the Web2SE workshop community.}
} 

@inproceedings{Treude:2011:SIW:1985793.1986056,
 author = {Treude, Christoph and Storey, Margaret-Anne and van Deursen, Arie and Begel, Andrew and Black, Sue},
 title = {Second International Workshop on Web 2.0 for Software Engineering},
 booktitle = {Proceedings of the 33rd International Conference on Software Engineering},
 series = {ICSE '11},
 year = {2011},
 month={June},
 yearMonth={2011-05},
 isbn = {978-1-4503-0445-0},
 location = {Waikiki, Honolulu, HI, USA},
 pages = {1222--1223},
 numpages = {2},
 doi = {10.1145/1985793.1986056},
 acmid = {1986056},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {collaboration, process, tools, web 2.0},
topicCode = {workshop hase socialmedia},
url={https://sites.google.com/site/web2se2011/}, 
localurl={papers/web2se-icse11.pdf},
abstract={Social software is built around an "architecture of
                  participation" where user data is aggregated as a
                  side-effect of using Web 2.0 applications. Web 2.0
                  implies that processes and tools are socially open,
                  and that content can be used in several different
                  contexts. Web 2.0 tools and technologies support
                  interactive information sharing, data
                  interoperability and user centered design. For
                  instance, wikis, blogs, tags and feeds help us
                  organize, manage and categorize content in an
                  informal and collaborative way. Some of these
                  technologies have made their way into collaborative
                  software development processes and development
                  platforms. These processes and environments are just
                  scratching the surface of what can be done by
                  incorporating Web 2.0 approaches and technologies
                  into collaborative software development. Web 2.0
                  opens up new opportunities for developers to form
                  teams and collaborate, but it also comes with
                  challenges for developers and researchers. Web2SE
                  aims to improve our understanding of how Web 2.0,
                  manifested in technologies such as mashups or
                  dashboards, can change the culture of collaborative
                  software development.}
} 

@inproceedings{Begel:2010:SMS:1882362.1882370,
 author = {Begel, Andrew and DeLine, Robert and Zimmermann, Thomas},
 title = {Social Media for Software Engineering},
 booktitle = {Proceedings of the FSE/SDP Workshop on Future of Software Engineering Research},
 series = {FoSER '10},
 year = {2010},
 month={November},
 yearMonth={2010-11},
 isbn = {978-1-4503-0427-6},
 location = {Santa Fe, New Mexico, USA},
 pages = {33-38},
 numpages = {6},
 doi = {10.1145/1882362.1882370},
 acmid = {1882370},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {privacy, social networking, software engineering, web 2.0},
topicCode = {hase socialmedia},
 localurl={papers/social-foser10.pdf},
abstract={Social media has changed the way that people collaborate and
                  share information. In this paper, we highlight its
                  impact for enabling new ways for software teams to
                  form and work together. Individuals will
                  self-organize within and across organizational
                  boundaries. Grassroots software development
                  communities will emerge centered around new
                  technologies, common processes and attractive target
                  markets. Companies consisting of lone individuals
                  will able to leverage social media to conceive of,
                  design, develop, and deploy successful and
                  profitable product lines. A challenge for
                  researchers who are interested in studying,
                  influencing, and supporting this shift in software
                  teaming is to make sure that their research methods
                  protect the privacy and reputation of their
                  stakeholders.}
} 

@inproceedings{Begel:2010:WFS:1882291.1882359,
 author = {Begel, Andrew and Phang, Khoo Yit and Zimmermann, Thomas},
 title = {WhoselsThat: Finding Software Engineers with Codebook. Demo.},
 booktitle = {Proceedings of the Eighteenth ACM SIGSOFT International Symposium on Foundations of Software Engineering},
 series = {FSE '10},
 year = {2010},
 month={November},
 yearMonth={2010-10},
 isbn = {978-1-60558-791-2},
 location = {Santa Fe, New Mexico, USA},
 pages = {381-382},
 numpages = {2},
 doi = {10.1145/1882291.1882359},
 acmid = {1882359},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {inter-team coordination, knowledge management, mining software repositories, social networking},
topicCode = {hase socialmedia tool},
 localurl={papers/whoseisthat-fse10.pdf},
abstract={In this demo, we describe WhoseIsThat, a social search
                  portal which we built using the Codebook
                  framework. We improve the search experience in two
                  ways: first, we search across multiple software
                  repositories at once with a single query; second, we
                  return not just a list of artifacts in the results,
                  but also engineers.}
}

@inproceedings{Begel:2010:CDE:1806799.1806821,
 author = {Begel, Andrew and Khoo, Yit Phang and Zimmermann, Thomas},
 title = {Codebook: Discovering and Exploiting Relationships in Software Repositories},
 booktitle = {Proceedings of the 32Nd ACM/IEEE International Conference on Software Engineering},
 series = {ICSE '10},
 year = {2010},
 month={May},
 isbn = {978-1-60558-719-6},
 location = {Cape Town, South Africa},
 pages = {125--134},
 numpages = {10},
 doi = {10.1145/1806799.1806821},
 acmid = {1806821},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {inter-team coordination, knowledge management, mining software repositories, regular expression, regular language reachability, social networking},
 yearMonth={2010-05},
 topicCode={hase socialmedia},
 localurl={papers/codebook-icse2010.pdf},
abstract={Large-scale software engineering requires communication and
                  collaboration to successfully build and ship
                  products. We conducted a survey with Microsoft
                  engineers on inter-team coordination and found that
                  the most impactful problems concerned finding and
                  keeping track of other engineers. Since engineers
                  are connected by their shared work, a tool that
                  discovers connections in their work-related
                  repositories can help.  

                  Here we describe the
                  Codebook framework for mining software
                  repositories. It is flexible enough to address all
                  of the problems identified by our survey with a
                  single data structure (graph of people and
                  artifacts) and a single algorithm (regular language
                  reachability). Codebook handles a larger variety of
                  problems than prior work, analyzes more kinds of
                  work artifacts, and can be customized by and for
                  end-users. To evaluate our framework's flexibility,
                  we built two applications, Hoozizat and Deep
                  Intellisense. We evaluated these applications with
                  engineers to show effectiveness in addressing
                  multiple inter-team coordination problems.}
} 



 
@inproceedings{Begel:2010:KUY:1809198.1809205,
 author = {Begel, Andrew and Zimmermann, Thomas},
 title = {Keeping Up with Your Friends: Function Foo, Library Bar.DLL, and Work Item 24},
 booktitle = {Proceedings of the First Workshop on Web 2.0 for Software Engineering},
 series = {Web2SE '10},
 year = {2010},
 month={May},
 yearMonth={2010-05},
 isbn = {978-1-60558-975-6},
 location = {Cape Town, South Africa},
 pages = {20--23},
 numpages = {4},
 doi = {10.1145/1809198.1809205},
 acmid = {1809205},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {inter-team coordination, knowledge management, mining software repositories, regular expression, regular language reachability, social networking},
topicCode = {hase socialmedia},
 localurl={papers/codebook-web2se2010.pdf},
abstract={Development teams who work with others need to be aware of
                  what everyone is doing in order to manage the risk
                  of taking on dependencies. Using newsfeeds of
                  software development activities mined from software
                  repositories, teams can find relevant information to
                  help them make well-informed decisions that affect
                  the success of their endeavors. In this paper, we
                  describe the architecture of a newsfeed system that
                  we are currently building on top of the Codebook
                  software repository mining platform. We discuss the
                  design, construction and aggregation of newsfeeds,
                  and include other important aspects such as
                  summarization, filtering, context, and privacy.}
}



@INPROCEEDINGS{5070997, 
 author={Begel, Andrew and DeLine, Robert}, 
 booktitle={Proceedings of 31st International Conference on Software Engineering}, 
 title={Codebook: Social Networking over Code}, 
 year={2009}, 
 month={May}, 
 yearMonth={2009-05},
 pages={263-266}, 
 abstract={Social networking systems help people maintain connections
                  to their friends, enabling awareness, communication,
                  and collaboration, especially at a distance. In many
                  studies of coordination in software engineering, the
                  work artifacts, e.g. code, bugs, specifications, are
                  themselves the objects that link engineers
                  together. In this paper, we introduce Codebook, a
                  social networking Web service in which people can be
                  ldquofriendsrdquo not only with other people but
                  with the work artifacts they share with
                  them. Providing a Web interface to the graph of
                  these connections will enable software engineers to
                  keep track of task dependencies, discover and
                  maintain connections to other teams, and understand
                  the history and rationale behind the code that they
                  work on and use.}, 
 keywords={Web services;social networking (online);software engineering;user interfaces;Codebook;Web interface;Web service;social networking system;software engineering;task dependency;work artifact}, 
 doi={10.1109/ICSE-COMPANION.2009.5070997},
 topicCode ={hase socialmedia},
 location={Vancouver, British Columbia, Canada},
 localurl={papers/codebook-icse2009.pdf}

}


@article{Begel:2010:TTC:1734797.1734821,
 author = {Begel, Andrew},
 title = {Three Things Every CS Educator Should Know About Their Students' Future Careers in Software Development: Keynote Address},
 journal = {Journal of Computing Sciences in Colleges},
 issue_date = {April 2010},
 volume = {25},
 number = {4},
 month = {April},
 year = {2010},
 yearMonth={2010-04},
 issn = {1937-4771},
 pages = {125--125},
 numpages = {1},
 url = {http://dl.acm.org/citation.cfm?id=1734797.1734821},
 acmid = {1734821},
 publisher = {Consortium for Computing Sciences in Colleges},
 address = {USA},
topicCode = {talk csed},
abstract={Computer science education is fundamentally about
                  transitioning students from novices to experts. As
                  students learn new hard and soft skills, and master
                  them, they grow more confident in their abilities
                  and interactions with others. We are pleased to see
                  them become big fish in a small pond. But, when
                  college graduates enter the software engineering
                  workforce, just how well do they fare? In this talk,
                  I'll show you three surprising challenges that we
                  saw newly graduated Computer Science students
                  overcome as they began careers in software
                  development at Microsoft. With the adoption of some
                  innovative pedagogical approaches in Computer
                  Science education already being taught in
                  universities around the world, I think we can ease
                  the transition and better prepare students for
                  positions in the software industry.}
}

@inproceedings{Begel:2009:CLS:1572193.1572204,
 author = {Begel, Andrew and Nagappan, Nachiappan and Poile, Christopher and Layman, Lucas},
 title = {Coordination in Large-scale Software Teams},
 booktitle = {Proceedings of the Workshop on Cooperative and Human Aspects on Software Engineering},
 series = {CHASE '09},
 year = {2009},
 month={May},
 yearMonth={2009-05},
 isbn = {978-1-4244-3712-2},
 pages = {1--7},
 numpages = {7},
 location={Vancouver, BC, Canada},
 doi = {10.1109/CHASE.2009.5071401},
 acmid = {1572204},
 publisher = {IEEE Computer Society},
 address = {Washington, DC, USA},
topicCode = {hase},
 localurl={papers/coordination-chase09.pdf},
abstract={Large-scale software development requires coordination
                  within and between very large engineering teams
                  which may be located in different buildings, on
                  different company campuses, and in different time
                  zones. From a survey answered by 775 Microsoft
                  software engineers, we learned how work was
                  coordinated within and between teams and how
                  engineers felt about their success at these
                  tasks. The respondents revealed that the most common
                  objects of coordination are schedules and features,
                  not code or interfaces, and that more communication
                  and personal contact worked better to make
                  interactions between teams go more smoothly. }
}



@TechReport{poile-techreport,
 author = {Begel, Andrew and Nagappan, Nachiappan and Poile, Christopher and Layman, Lucas},
 title = {Coordination in Large-scale Software Development: Helpful and Unhelpful Behaviors},
  institution =  {Microsoft Research},
  year = 	 {2011},
  number =	 {MSR-TR-2011-136},
  location= 	 {Redmond, Washington},
  month = 	 {April},
yearMonth={2011-04},
topicCode={hase},
localurl={papers/coordination-techreport08.pdf},
abstract={Large-scale software development requires coordination
                  within and between very large engineering teams
                  which may be located in different buildings, on
                  different company campuses, and in different time
                  zones. At Microsoft Corporation, we studied a
                  3-year-old, 300-person software application team
                  based in Redmond, WA to learn how they coordinate
                  with three intra-organization, physically
                  distributed dependencies: a platform library team
                  also in Redmond; a team three time zones away in
                  Boston, MA; and a team in Hyderabad,
                  India. Thirty-one interviews with 26 team members
                  revealed that coordination was most impacted by
                  issues of communication, capacity and
                  cooperation. Distributed teams faced additional
                  challenges due to time zone and cultural differences
                  between the team members. We support our findings
                  with a survey of 775 engineers across Microsoft who
                  described their experiences managing coordination in
                  their own software products. We suggest new
                  processes and tools to improve team coordination.}
}

@article{Begel:2009:TTC:1516546.1516572,
 author = {Begel, Andrew},
 title = {Three Things Every CS Educator Should Know About Their Students' Future Careers in Software Development},
 journal = {Journal of Computing Sciences in Colleges},
 issue_date = {April 2009},
 volume = {24},
 number = {4},
 month = {April},
 year = {2009},
 yearMonth={2009-04},
 issn = {1937-4771},
 pages = {143--143},
 numpages = {1},
 url = {http://dl.acm.org/citation.cfm?id=1516546.1516572},
 acmid = {1516572},
 publisher = {Consortium for Computing Sciences in Colleges},
 address = {USA},
topicCode = {talk csed},
abstract={Computer science education is fundamentally about
                  transitioning students from novices to experts. As
                  students learn new hard and soft skills, and master
                  them, they grow more confident in their abilities
                  and interactions with others. We are pleased to see
                  them become big fish in a small pond. But, when
                  college graduates enter the software engineering
                  workforce, just how well do they fare? In this talk,
                  I'll show you three surprising challenges that we
                  saw newly graduated Computer Science students
                  overcome as they began careers in software
                  development at Microsoft. With the adoption of some
                  innovative pedagogical approaches in Computer
                  Science education already being taught in
                  universities around the world, I think we can ease
                  the transition and better prepare students for
                  positions in the software industry.}
}

@inproceedings{Begel:2008:PPW:1414004.1414026,
 author = {Begel, Andrew and Nagappan, Nachiappan},
 title = {Pair Programming: What's In It for Me?},
 booktitle = {Proceedings of the Second ACM-IEEE International Symposium on Empirical Software Engineering and Measurement},
 series = {ESEM '08},
 year = {2008},
 month={October},
 yearMonth={2008-10},
 isbn = {978-1-59593-971-5},
 location = {Kaiserslautern, Germany},
 pages = {120--128},
 numpages = {9},
 doi = {10.1145/1414004.1414026},
 acmid = {1414026},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {developers, empirical studies, pair programming, survey experiments},
topicCode = {hase},
 localurl={papers/esem-begel-2008.pdf},
abstract={Pair programming is a practice in which two programmers work
                  collaboratively at one computer on the same design,
                  algorithm, or code. Prior research on pair
                  programming has primarily focused on its evaluation
                  in academic settings. There has been limited
                  evidence on the use, problems and benefits, partner
                  selection, and the general perceptions towards pair
                  programming in industrial settings. In this paper we
                  report on a longitudinal evaluation of pair
                  programming at Microsoft Corporation. We find from
                  the results of a survey sent to a randomly selected
                  10\% of engineers at Microsoft that 22\% pair
                  program or have pair programmed in the past. Using
                  qualitative analysis, we performed a large-scale
                  card sort to group the various benefits and problems
                  of pair programming. The biggest perceived benefits
                  of pair programming were the introduction of fewer
                  bugs, spreading code understanding, and producing
                  overall higher quality code. The top problems were
                  cost-efficiency, (work time) scheduling problems,
                  and personality conflicts. Most engineers preferred
                  a partner who had complementary skills to their own,
                  who was flexible and had good communication skills.}
}

@inproceedings{Begel:2008:NSD:1404520.1404522,
 author = {Begel, Andrew and Simon, Beth},
 title = {Novice Software Developers, All over Again},
 booktitle = {Proceedings of the Fourth International Workshop on Computing Education Research},
 series = {ICER '08},
 year = {2008},
 month={August},
 yearMonth={2008-08},
 isbn = {978-1-60558-216-0},
 location = {Sydney, Australia},
 pages = {3--14},
 numpages = {12},
 doi = {10.1145/1404520.1404522},
 acmid = {1404522},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {computer science pedagogy, human aspects of software engineering, software development, training},
topicCode = {csed hase},
 localurl={papers/icer-begel-2008.pdf},
abstract={Transitions from novice to expert often cause stress and
                  anxiety and require specialized instruction and
                  support to enact efficiently. While many studies
                  have looked at novice computer science students,
                  very little research has been conducted on
                  professional novices. We conducted a two-month
                  in-situ qualitative case study of new software
                  developers in their first six months working at
                  Microsoft. We shadowed them in all aspects of their
                  jobs: coding, debugging, designing, and engaging
                  with their team, and analyzed the types of tasks in
                  which they engage. We can explain many of the
                  behaviors revealed by our analyses if viewed through
                  the lens of newcomer socialization from the field of
                  organizational man-agement. This new perspective
                  also enables us to better understand how current
                  computer science pedagogy prepares students for jobs
                  in the software industry. We consider the
                  implications of this data and analysis for
                  developing new processes for learning in both
                  university and industrial settings to help
                  accelerate the transition from novice to expert
                  software developer.}
} 

@inproceedings{Begel:2008:ECC:1370114.1370119,
 author = {Begel, Andrew},
 title = {Effecting Change: Coordination in Large-scale Software Development},
 booktitle = {Proceedings of the International Workshop on Cooperative and Human Aspects of Software Engineering},
 series = {CHASE '08},
 year = {2008},
 month={May},
 yearMonth={2008-05},
 isbn = {978-1-60558-039-5},
 location = {Leipzig, Germany},
 pages = {17--20},
 numpages = {4},
 doi = {10.1145/1370114.1370119},
 acmid = {1370119},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {coordination, distributed development},
topicCode = {hase},
 localurl={papers/effecting-change.pdf},
abstract={Large-scale software development requires coordination
                  within and between very large engineering teams,
                  each of which may be located in different locations
                  and time zones. Numerous studies, and indeed, a
                  whole conference (ICGSE), are dedicated to
                  discovering the causes of problems with distributed
                  development in the software industry. Microsoft has
                  long had product teams too large to be considered
                  co-located, even when sitting in neighboring
                  buildings on the same campus. Recently, it has been
                  expanding its engineering workforce into India and
                  China, and our research is showing that Microsoft is
                  encountering many of the coordination problems that
                  go along with differences of location, time zone,
                  and culture. As we go forward, our research has been
                  changing from learning about the problem to
                  experimenting with solutions. What are the best
                  practices for improving coordination? Can they be
                  applied to all software teams? How does one move
                  past simple readings of research results towards
                  effective intervention?}
} 

@inproceedings{Layman:2008:MSE:1370750.1370762,
 author = {Layman, Lucas and Nagappan, Nachiappan and Guckenheimer, Sam and Beehler, Jeff and Begel, Andrew},
 title = {Mining Software Effort Data: Preliminary Analysis of Visual Studio Team System Data},
 booktitle = {Proceedings of the 2008 International Working Conference on Mining Software Repositories},
 series = {MSR '08},
 year = {2008},
 month={May},
 yearMonth={2008-05},
 isbn = {978-1-60558-024-1},
 location = {Leipzig, Germany},
 pages = {43--46},
 numpages = {4},
 doi = {10.1145/1370750.1370762},
 acmid = {1370762},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {effort estimation, prediction},
topicCode = {hase},
 localurl={papers/effort-estimation.pdf},
abstract={In the software development process, scheduling and
                  predictability are important components to
                  delivering a product on time and within
                  budget. Effort estimation artifacts offer a rich
                  data set for improving scheduling accuracy and for
                  understanding the development process. Effort
                  estimation data for 55 features in the latest
                  release of Visual Studio Team System (VSTS) were
                  collected and analyzed for trends, patterns, and
                  differences. Statistical analysis shows that actual
                  estimation error was positively correlated with
                  feature size, and that in-process metrics of
                  estimation error were also correlated with the final
                  estimation error. These findings suggest that
                  smaller features can be estimated more accurately,
                  and that in-process estimation error metrics can be
                  provide a quantitative supplement to developer
                  intuition regarding high-risk features during the
                  development process.}
} 

@inproceedings{Klopfer:2004:PRE:1149126.1149203,
 author = {Klopfer, Eric and Resnick, Mitchel and Maloney, John and Silverman, Brian and diSessa, Andrea and Begel, Andrew and Hancock, Chris},
 title = {Programming Revisited: The Educational Value of Computer Programming},
 booktitle = {Proceedings of the 6th International Conference on Learning Sciences},
 series = {ICLS '04},
 year = {2004},
 month={June},
 yearMonth={2004-06},
 location = {Santa Monica, California},
 pages = {16-18},
 numpages = {3},
 url = {http://dl.acm.org/citation.cfm?id=1149126.1149203},
 acmid = {1149203},
 publisher = {International Society of the Learning Sciences},
topicCode = {csed panel proglang},
localurl={papers/icls04.pdf},
abstract={This panel will address pedagogical needs for revisiting the
                  role of computer programming for student
                  learning. We will explore advances in programming
                  platforms that enable students to create compelling
                  projects with new technologies, and discuss the
                  affordances of these new initiatives. We will
                  address how these tools and techniques can be
                  integrated into the curriculum of the classroom as
                  well as informal learning environments. }
}

@inproceedings{Holmes:2008:DIT:1370750.1370755,
 author = {Holmes, Reid and Begel, Andrew},
 title = {Deep Intellisense: A Tool for Rehydrating Evaporated Information},
 booktitle = {Proceedings of the 2008 International Working Conference on Mining Software Repositories},
 series = {MSR '08},
 year = {2008},
 month={May},
 yearMonth={2008-05},
 isbn = {978-1-60558-024-1},
 location = {Leipzig, Germany},
 pages = {23--26},
 numpages = {4},
 doi = {10.1145/1370750.1370755},
 acmid = {1370755},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {code investigation, mining repositories},
topicCode = {hase tool},
 localurl={papers/deep-intellisense.pdf},
abstract={Software engineers working in large teams on large,
                  long-lived code-bases have trouble understanding why
                  the source code looks the way does. Often, they
                  answer their questions by looking at past revisions
                  of the source code, bug reports, code checkins,
                  mailing list messages, and other documentation. This
                  process of inquiry can be quite inefficient,
                  especially when the answers they seek are located in
                  isolated repositories accessed by multiple
                  independent investigation tools. Prior mining
                  approaches have focused on linking various data
                  repositories together; in this paper we investigate
                  techniques for displaying information extracted from
                  the repositories in a way that helps developers to
                  build a cohesive mental model of the rationale
                  behind the code. After interviewing several
                  developers and testers about how they investigate
                  source code, we created a Visual Studio plugin
                  called Deep Intellisense that summarizes and
                  displays historical information about source
                  code. We designed Deep Intellisense to address many
                  of the hurdles engineers face with their current
                  techniques, and help them spend less time gathering
                  information and more time getting their work done.}
} 

@inproceedings{Begel:2004:KLC:971300.971367,
 author = {Begel, Andrew and Garcia, Daniel D. and Wolfman, Steven A.},
 title = {Kinesthetic Learning in the Classroom. Special Session.},
 booktitle = {Proceedings of the 35th SIGCSE Technical Symposium on Computer Science Education},
 series = {SIGCSE '04},
 year = {2004},
 month={March},
 yearMonth={2004-03},
 isbn = {1-58113-798-2},
 location = {Norfolk, Virginia, USA},
 pages = {183--184},
 numpages = {2},
 doi = {10.1145/971300.971367},
 acmid = {971367},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Kinesthetic learning style, active learning, sensorimotor learning},
topicCode = {csed},
 localurl={papers/kla.pdf},
abstract={We propose a special session focusing on kinesthetic
                  learning activities, i.e., physically engaging
                  classroom exercises. These might, for example,
                  involve throwing a frisbee around the classroom to
                  represent transfer of control in a procedure call,
                  or simulating polygon scan conversion with rope for
                  edges and students for pixels.  The session will
                  begin with a brief kinesthetic learning activity to
                  motivate the value of these activities. We will
                  follow with a variety of examples, and discuss how
                  to deploy these in a classroom. In the middle of the
                  session, the audience will divide into facilitated
                  groups to design their own activities. Finally, we
                  will all mingle to share and discuss the results. We
                  will set up a public web forum for continued
                  discussion and generation of new ideas.}
} 

@inproceedings{Begel:1999:BEG:316188.316214,
 author = {Begel, Andrew and McCanne, Steven and Graham, Susan L.},
 title = {BPF+: Exploiting Global Data-flow Optimization in a Generalized Packet Filter Architecture},
 booktitle = {Proceedings of the Conference on Applications, Technologies, Architectures, and Protocols for Computer Communication},
 series = {SIGCOMM '99},
 year = {1999},
 month={September},
 yearMonth={1999-09},
 isbn = {1-58113-135-6},
 location = {Cambridge, Massachusetts, USA},
 pages = {123--134},
 numpages = {12},
 doi = {10.1145/316188.316214},
 acmid = {316214},
 publisher = {ACM},
 address = {New York, NY, USA},
topicCode = {proglang tool},
 localurl={papers/bpf.pdf},
abstract={A packet filter is a programmable selection criterion for
                  classifying or selecting packets from a packet
                  stream in a generic, reusable fashion. Previous work
                  on packet filters falls roughly into two categories,
                  namely those efforts that investigate flexible and
                  extensible filter abstractions but sacrifice
                  performance, and those that focus on low-level,
                  optimized filtering representations but sacrifice
                  flexibility. Applications like network monitoring
                  and intrusion detection, however, require both
                  high-level expressiveness and raw performance. In
                  this paper, we propose a fully general packet filter
                  framework that affords both a high degree of
                  flexibility and good performance. In our framework,
                  a packet filter is expressed in a high-level
                  language that is compiled into a highly efficient
                  native implementation. The optimization phase of the
                  compiler uses a flowgraph set relation called edge
                  dominators and the novel application of an
                  optimization technique that we call "redundant
                  predicate elimination," in which we interleave
                  partial redundancy elimination, predicate assertion
                  propagation, and flowgraph edge elimination to carry
                  out the filter predicate optimization. Our resulting
                  packet-filtering framework, which we call BPF+,
                  derives from the BSD packet filter (BPF), and
                  includes a filter program translator, a byte code
                  optimizer, a byte code safety verifier to allow code
                  to migrate across protection boundaries, and a
                  just-in-time assembler to convert byte codes to
                  efficient native code. Despite the high degree of
                  flexibility afforded by our generalized framework,
                  our performance measurements show that our system
                  achieves performance comparable to state-of-the-art
                  packet filter architectures and better than
                  hand-coded filters written in C. }
} 

@inproceedings{Begel:2008:SNC:1352135.1352218,
 author = {Begel, Andrew and Simon, Beth},
 title = {Struggles of New College Graduates in Their First Software Development Job},
 booktitle = {Proceedings of the 39th SIGCSE Technical Symposium on Computer Science Education},
 series = {SIGCSE '08},
 year = {2008},
 month={March},
 yearMonth={2008-03},
 isbn = {978-1-59593-799-5},
 location = {Portland, OR, USA},
 pages = {226--230},
 numpages = {5},
 doi = {10.1145/1352135.1352218},
 acmid = {1352218},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {computer science education, human aspects of software engineering, software development},
topicCode = {csed hase},
 localurl={papers/sigcse-begel-2008.pdf},
abstract={How do new college graduates experience their first software
                  development jobs? In what ways are they prepared by
                  their educational experiences, and in what ways do
                  they struggle to be productive in their new
                  positions? We report on a "fly-on-the-wall"
                  observational study of eight recent college
                  graduates in their first six months of a software
                  development position at Microsoft Corporation. After
                  a total of 85 hours of on-the-job observation, we
                  report on the common abilities evidenced by new
                  software developers including how to program, how to
                  write design specifications, and evidence of
                  persistence strategies for problem-solving. We also
                  classify some of the common ways new software
                  developers were observed getting stuck:
                  communication, collaboration, technical, cognition,
                  and orientation. We report on some common
                  misconceptions of new developers which often
                  frustrate them and hinder them in their jobs, and
                  conclude with recommendations to align Computer
                  Science curricula with the observed needs of new
                  professional developers.}
}

@INPROCEEDINGS{5876140, 
 author={Gannod, Gerald C. and Anderson, Paul V. and Burge, Janet E. and Begel, Andrew}, 
 booktitle={Proceedings of the 24th IEEE-CS Conference on Software Engineering Education and Training (CSEE\&T)}, 
 title={Is Integration of Communication and Technical Instruction
                  across the SE Curriculum a Viable Strategy for
                  Improving the Real-World Communication Abilities of
                  Software Engineering Graduates?}, 
 year={2011}, 
 month={May}, 
 yearMonth={2011-05},
 pages={525-529}, 
 location={Honolulu, Hawaii},
 abstract={Software engineering educators and trainers are acutely
                  aware that software engineering graduates need
                  strong real-world communication abilities. The
                  National Science Foundation is supporting a
                  three-year project in which industry professionals,
                  CS/SE faculty, and
                  communication-across-the-curriculum specialists are
                  collaborating to develop curricula and teaching
                  resources designed to improve communication
                  abilities of CS/SE graduates by integrating
                  communication instruction and assignments with the
                  technical work in courses across the students' four
                  years of study. Our panelists -- an industry
                  practitioner, a CS/SE educator, and a communication
                  specialist -- will describe what has been learned in
                  the project's first half and invite comments,
                  insights and advice from the audience.}, 
 doi={10.1109/CSEET.2011.5876140}, 
 ISSN={1093-0175},
topicCode = {csed panel},

}

@INPROCEEDINGS{4343753, 
 author={Begel, Andrew and Nagappan, Nachiappan}, 
 booktitle={Proceedings of the 1st International Symposium on Empirical Software Engineering and Measurement, 2007}, 
 title={Usage and Perceptions of Agile Software Development in an Industrial Context: An Exploratory Study}, 
 year={2007}, 
 month={September}, 
 yearMonth={2007-09},
 pages={255-264}, 
 location={Madrid, Spain},
 abstract={Agile development methodologies have been gaining
                  acceptance in the mainstream software development
                  community. While there are numerous studies of agile
                  development in academic and educational settings,
                  there has been little detailed reporting of the
                  usage, penetration and success of agile
                  methodologies in traditional, professional software
                  development organizations. We report on the results
                  of an empirical study conducted at Microsoft to
                  learn about agile development and its perception by
                  people in development, testing, and management. We
                  found that one-third of the study respondents use
                  agile methodologies to varying degrees, and most
                  view it favorably due to improved communication
                  between team members, quick releases and the
                  increased flexibility of agile designs. The scrum
                  variant of agile methodologies is by far the most
                  popular at Microsoft. Our findings also indicate
                  that developers are most worried about scaling agile
                  to larger projects (greater than twenty members),
                  attending too many meetings and the coordinating
                  agile and non-agile teams.}, 
 keywords={software development management;Scrum variant;agile software development;industrial context;Collaborative software;Computer industry;Gain measurement;Large-scale systems;Productivity;Programming;Software engineering;Software measurement;Testing;Variable speed drives}, 
 doi={10.1109/ESEM.2007.12}, 
 ISSN={1938-6451},
 topicCode = {agile hase},
 localurl={papers/AgileDevAtMS-ESEM07.pdf}

}

@INPROCEEDINGS{4638666, 
 author={Begel, Andrew and Nagappan, Nachiappan}, 
 booktitle={Proceedings of IEEE International Conference on Global Software Engineering}, 
 title={Global Software Development: Who Does It?}, 
 year={2008}, 
 month={August}, 
 yearMonth={2008-08},
 pages={195-199}, 
location={Bangalore, India},
 abstract={In today's world, software development is increasingly
                  spread across national and geographic
                  boundaries. There is limited empirical evidence
                  about the number and distribution of people in a
                  large software company who have to deal with global
                  software development (GSD). Is GSD restricted to a
                  select few in a company? How many time zones do
                  engineers have to deal with? Do managers have to
                  deal with GSD more than individual engineers? What
                  are the benefits and problems that engineers see
                  with GSD? How have they tried to improve GSD
                  coordination? These are interesting questions to be
                  addressed in an empirical context. In this paper, we
                  report on the results of a large-scale survey of
                  software engineers at Microsoft Corporation. We
                  found that a very high proportion of engineers are
                  directly involved with GSD. In addition, more than
                  50\% of the respondents regularly collaborate with
                  people more than three time zones away. Engineers
                  also report that communication difficulties around
                  coordination are the most critical, yet difficult to
                  solve issues with GSD.}, 
 keywords={globalisation;project management;software development management;team working;global software development;project management;software company;Acceleration;Collaboration;Engineering management;Knowledge management;Programming;Project management;Software engineering;Time to market;USA Councils;Virtual groups}, 
 doi={10.1109/ICGSE.2008.17},
 topicCode = {gsd hase},
 localurl={papers/icgse-begel-2008.pdf}

}

@INPROCEEDINGS{1372335, 
 author={Begel, Andrew}, 
 booktitle={Proceedings of the IEEE Symposium on Visual Languages and Human Centric Computing}, 
 title={Spoken Language Support for Software Development}, 
 year={2004}, 
 month={September}, 
 yearMonth={2004-09},
 location={Rome, Italy}
 pages={271-272}, 
 abstract={Software development environments have changed little since
                  their origins as low-level text editors. Programmers
                  with repetitive strain injuries and other motor
                  disabilities can find these environments difficult
                  or impossible to use due to their emphasis on
                  typing. Our research adapts voice recognition to the
                  software development process, both to mitigate this
                  difficulty and to provide insight into natural forms
                  of high-level interaction. Our contribution is to
                  use program analysis to interpret speech as code,
                  thereby enabling the creation of a program editor
                  that supports voice-based programming. We have
                  created spoken Java, a variant of Java which is
                  easier to verbalize than its traditional typewritten
                  form, and an associated spoken command language to
                  manipulate code. We are conducting user studies to
                  understand the cognitive effects of spoken
                  programming, as well as to inform the design of the
                  language and editor.}, 
 keywords={Java;program diagnostics;software tools;speech recognition;speech synthesis;code manipulation;program analysis;program editor;software development;speech interpretation;spoken Java;spoken language support;spoken programming;voice recognition;voice-based programming;Capacitive sensors;Command languages;Injuries;Java;Natural languages;Navigation;Programming profession;Speech analysis;Speech recognition;Virtual reality}, 
 doi={10.1109/VLHCC.2004.49},
 topicCode = {proglang hase tool},
 localurl={papers/vlhcc-spoken-language04.pdf}

}

@INPROCEEDINGS{1698772, 
 author={Begel, Andrew and Graham, Susan L.}, 
 booktitle={Proceedings of the IEEE Symposium on Visual Languages and Human-Centric Computing}, 
 title={An Assessment of a Speech-Based Programming Environment}, 
 year={2006}, 
 month={September}, 
 yearMonth={2006-09},
 pages={116-120}, 
 location={Brighton, England, United Kingdom},
 abstract={Programmers who suffer from repetitive stress injuries find
                  it difficult to program by typing. Speech interfaces
                  can reduce the amount of typing, but existing
                  programming-by-voice tools make it awkward for
                  programmers to enter and edit program text. We used
                  a human-centric approach to address these
                  problems. We first studied how programmers verbalize
                  code, and found that spoken programs contain
                  lexical, syntactic and semantic ambiguities that do
                  not appear in written programs. Using the results
                  from this study, we designed Spoken Java, a
                  syntactically similar, yet semantically identical
                  variant of Java that is easier to speak. We built an
                  Eclipse IDE plug-in called SPEED (for speech editor)
                  to support the combination of Spoken Java and an
                  associated command language. In this paper, we
                  report the results of the first study ever of any
                  working programming-by-voice system. Our evaluation
                  with expert Java developers showed that most
                  developers had little trouble learning to use the
                  system via spoken commands, but were reluctant to
                  speak literal code out loud. As expected,
                  programmers found programming by voice to be slower
                  than typing}, 
 keywords={Java;programming environments;speech synthesis;speech-based user interfaces;Eclipse IDE;SPEED plug-in;Spoken Java;programming-by-voice system;speech editor;speech interfaces;speech-based programming environment;spoken programming commands;Capacitive sensors;Command languages;Humans;Injuries;Java;Natural languages;Programming environments;Programming profession;Speech recognition;Stress}, 
 doi={10.1109/VLHCC.2006.9},
 topicCode = {proglang hase tool},
 localurl={papers/speed-short-paper.pdf}

}

@INPROCEEDINGS{1372317, 
 author={Toomim, Michael and Begel, Andrew and Graham, Susan L.}, 
 booktitle={Proceedings of IEEE Symposium on Visual Languages and Human Centric Computing}, 
 title={Managing Duplicated Code with Linked Editing}, 
 year={2004}, 
 month={September}, 
 yearMonth={2004-09},
 pages={173-180}, 
 location={Rome, Italy},
 abstract={We present linked editing, a novel, lightweight
                  editor-based technique for managing duplicated
                  source code. Linked editing is implemented in a
                  prototype editor called Codelink. We argue that the
                  use of programming abstractions like functions and
                  macros - the traditional solution to duplicated code
                  - has inherent cognitive costs, leading programmers
                  to chronically copy and paste code instead. Our user
                  study compares functional abstraction with linked
                  editing and shows that linked editing can give the
                  benefits of abstraction with orders of magnitude
                  decrease in programming time}, 
 keywords={macros;software engineering;text editing;Codelink;cognitive costs;duplicated source code;functional abstraction;lightweight editor-based technique;linked editing;macros;programming abstractions;programming time;Cloning;Computer languages;Computer science;Cost function;Functional programming;Linux;Object oriented programming;Programming profession;Prototypes;Software systems}, 
 doi={10.1109/VLHCC.2004.35},
 topicCode = {hase tool},
 localurl={papers/toomim-linked-editing.pdf},

}

@INPROCEEDINGS{805221, 
 author={Spreitzer, Michael and Begel, Andrew}, 
 booktitle={Proceedings of 8th International Workshop on Enabling Technologies: Infrastructure for Collaborative Enterprises}, 
 title={More Flexible Data Types}, 
 year={1999}, 
 month={June}, 
 yearMonth={1999-06},
 pages={319-324}, 
 location={Stanford, California},
 abstract={XML can play several roles in a distributed object
                  system. In particular, data can be serialized in
                  XML-based formats. XML-encoded data can be more
                  self-describing than data encoded in many more
                  traditional ways, which facilitates the kind of
                  decentralized protocol evolution seen in
                  Internet-scale development: XML's explicit "tagging
                  and bagging" helps keep extensions
                  straight. However, today's common distributed object
                  systems have type systems that are not flexible
                  enough to describe such data. We suggest a way to
                  make more flexible data types; this improves
                  distributed object systems in general, and is
                  critical to realizing XML's full potential. This
                  approach has: (1) typing judgements based on type
                  structure instead of type identity, (2) extensible
                  record types with optional fields, (3) coarse record
                  types, for which extension is compatible with
                  subtyping, and (4) non-ignorable fields in record
                  values}, 
 keywords={data structures;distributed object management;hypermedia markup languages;Internet-scale development;XML;XML-based formats;XML-encoded data;coarse record types;decentralized protocol evolution;distributed object system;extensible record types;flexible data types;nonignorable fields;optional field;record values;subtyping;type structure;type systems;typing judgements;Computer languages;Distributed power generation;Electrical capacitance tomography;Encoding;Explosions;Identity-based encryption;Internet;Java;Power generation;XML}, 
 doi={10.1109/ENABL.1999.805221}, 
 ISSN={1080-1383},
 topicCode = {proglang},
 localurl={wetice99.pdf}

}

@INPROCEEDINGS{1509493, 
 author={Begel, Andrew and Graham, Susan L.}, 
 booktitle={Proceedings of IEEE Symposium on Visual Languages and Human-Centric Computing}, 
 title={Spoken Programs}, 
 year={2005}, 
 month={September}, 
 yearMonth={2005-09},
 pages={99-106}, 
location={Dallas, Texas},
 abstract={Programmers who suffer from repetitive stress injuries find
                  it difficult to spend long amounts of time typing
                  code. Speech interfaces can help developers reduce
                  their dependence on typing. However, existing
                  programming by voice techniques make it awkward for
                  programmers to enter and edit program text. To
                  design a better alternative, we conducted a study to
                  learn how software developers naturally verbalize
                  programs. We found that spoken programs are
                  different from written programs in ways similar to
                  the differences between spoken and written English;
                  spoken programs contain lexical, syntactic and
                  semantic ambiguities that do not appear in written
                  programs. Using the results from this study, we
                  designed Spoken Java, a semantically identical
                  variant of Java that is easier to say out
                  loud. Using Spoken Java, software developers can
                  speak more naturally by verbalizing their program
                  code as if they were reading it out loud. Spoken
                  Java is analyzed by extending a conventional Java
                  programming language analysis engine written in our
                  Harmonia program analysis framework to support the
                  kinds of ambiguities that arise from speech.}, 
 keywords={Java;computer aided software engineering;speech-based user interfaces;English language;Harmonia program analysis;Java programming language;Spoken Java;lexical ambiguity;program code verbalization;programming by voice;semantic ambiguity;software development;speech interfaces;spoken programs;syntactic ambiguity}, 
 doi={10.1109/VLHCC.2005.58},
 topicCode = {proglang hase tool},
 localurl={papers/begel-spoken-java.pdf}

}

@INPROCEEDINGS{5970193, 
 author={Begel, Andrew and Quante, Jochen}, 
 booktitle={Proceedings of the 19th International Conference on Program Comprehension}, 
 title={Industrial Program Comprehension Challenge 2011: Archeology and Anthropology of Embedded Control Systems}, 
 year={2011}, 
 month={June}, 
 yearMonth={2011-06},
 pages={227-229}, 
 location={Kingston, Ontario, Canada},
 abstract={The Industrial Program Comprehension Challenge is a
                  two-year-old track of the International Conference
                  on Program Comprehension that provides a venue for
                  researchers and industrial practitioners to
                  communicate about new research directions that can
                  help address real world problems. This year, 2011, a
                  scenario-based challenge was created to inspire
                  researchers to apply the best "archaeological"
                  techniques for understanding the complexity of
                  industrial software, and foster appreciation for the
                  delicate "anthropological" scenario which drives the
                  behavior of the software engineers, management, and
                  customers. Participants had two months to work on
                  the challenge and submit write-ups of their
                  solutions. Acceptable submissions were exhibited as
                  posters, while the best solutions were presented
                  during the Industrial Challenge conference
                  session. This new challenge format gives researchers
                  the opportunity to present their novel techniques,
                  tools and ideas to the community.}, 
 keywords={embedded systems;production engineering computing;software engineering;Industrial Program Comprehension Challenge;anthropology;archeology;embedded control systems;industrial software;Companies;Computer bugs;Electronic mail;Leg;Legged locomotion;Software}, 
 doi={10.1109/ICPC.2011.50}, 
 ISSN={1092-8138},
 topicCode = {hase},
 localurl={papers/industry-challenge-icpc11.pdf}

}

@INPROCEEDINGS{5521747, 
 author={Begel, Andrew}, 
 booktitle={Proceedings of the 18th International Conference on Program Comprehension}, 
 title={From Program Comprehension to People Comprehension}, 
 year={2010}, 
 month={June}, 
 yearMonth={2010-06},
 pages={190-191},
 location={Braga, Portugal}, 
 abstract={Large-scale software engineering requires many teams to
                  collaborate together to create software
                  products. The problems these teams suffer trying to
                  coordinate their joint work can be addressed through
                  tools inspired by social networking. Social
                  networking tools help people to more easily discover
                  and more efficiently maintain relationships than is
                  feasible using one-to-one or face-to-face
                  interactions. Applying these ideas to the software
                  domain requires new kinds and combinations of
                  software program and process analyses that overcome
                  intrinsic limitations in the accuracy of the
                  underlying data sources and the ambiguity inherent
                  in human relationships.}, 
 keywords={social aspects of automation;social networking (online);software engineering;human aspects;people comprehension;program comprehension;social networking tools;software products;software program;Collaborative software;Collaborative work;Computer bugs;Data engineering;Data mining;Humans;Social network services;Software engineering;Software testing;USA Councils;human aspects;software process}, 
 doi={10.1109/ICPC.2010.42}, 
 ISSN={1092-8138},
 topicCode = {hase panel},
 localurl={papers/people-icpc10.pdf}

}

@ARTICLE{6401114, 
 author={Begel, Andrew and Bosch, Jan and Storey, Margaret-Anne}, 
 journal={IEEE Software}, 
 title={Social Networking Meets Software Development: Perspectives from GitHub, MSDN, Stack Exchange, and TopCoder}, 
 year={2013}, 
 month={January}, 
 yearMonth={2013-01},
 volume={30}, 
 number={1}, 
 pages={52-66}, 
 abstract={Many successful software companies use social networking as
                  a way to improve the services or products they
                  provide. To gain an understanding of the role social
                  networking plays in today's software development
                  world, the guest editors of the January/February
                  2013 issue conducted semistructured interviews with
                  leaders from four successful companies: Brian Doll,
                  an engineer who manages GitHub's marketing; Doug
                  Laundry, a principal group program manager at
                  Microsoft; David Fullerton, vice president of
                  engineering at Stack Exchange; and Robert Hughes,
                  the president and chief operating officer of
                  TopCoder. The first Web extra at
                  http://try.github.com is a video of Joel Spolsky
                  discussing the structure, software, technology, and
                  culture of Stack Exchange. The second Web extra at
                  http://blip.tv/play/gvUBgqLbRgI.html is a video of
                  Matthew McCullough and Tim Berglund demonstrating
                  how Git not only incorporates the best features of
                  existing source control systems but also includes
                  unique distributed capabilities that make version
                  control commands available without connectivity,
                  allowing you to choose when to interact with a
                  network. The third Web extra at
                  http://blip.tv/play/gvUBgqLbRgI.html is a video of
                  Matthew McCullough and Tim Berglund demonstrating
                  how to leverage Git's powerful yet underused
                  advanced features. The last Web extra at
                  http://youtu.be/SK6TBI1bNLI is a video of Thomas
                  Baden, Chief Information Officer, State of
                  Minnesota, Department of Human Services, describing
                  the experience of working on the TopCoder Platform
                  and with the members of the TopCoder Community.}, 
 keywords={Internet;configuration management;marketing;social networking (online);software engineering;GitHub marketing;MSDN;Microsoft;TopCoder community;TopCoder platform;principal group program manager;second Web extra;social networking;software companies;source control systems;stack exchange;third Web extra;today software development world;unique distributed capabilities;Human factors;Social network services;Software development;Github;Microsoft;Stack Exchange;TopCoder;community;social networking;software}, 
 doi={10.1109/MS.2013.13}, 
 ISSN={0740-7459},
 topicCode = {hase socialmedia},

}

@INPROCEEDINGS{6681340, 
 author={Murphy, Brendan and Bird, Christian and Zimmermann, Thomas and Williams, Laurie and Nagappan, Nachiappan and Begel, Andrew}, 
 booktitle={Proceedings of ACM / IEEE International Symposium on Empirical Software Engineering and Measurement}, 
 title={Have Agile Techniques been the Silver Bullet for Software Development at Microsoft?}, 
 year={2013}, 
 location={Baltimore, Maryland},
 month={October}, 
 yearMonth={2013-09},
 pages={75-84}, 
 abstract={Background. The pressure to release high-quality, valuable
                  software products at an increasingly faster rate is
                  forcing software development organizations to adapt
                  their development practices. Agile techniques began
                  emerging in the mid-1990s in response to this
                  pressure and to increased volatility of customer
                  requirements and technical change. Theoretically,
                  agile techniques seem to be the silver bullet for
                  responding to these pressures on the software
                  industry. 

                  Aims. This paper tracks the changing
                  attitudes to agile adoption and techniques, within
                  Microsoft, in one of the largest longitudinal
                  surveys of its kind (2006-2012). 

                  Method. We
                  collected the opinions of 1,969 agile and non-agile
                  practitioners in five surveys over a six-year
                  period. 

                  Results. The survey results reveal that
                  despite intense market pressure, the growth of agile
                  adoption at Microsoft is slower than would be
                  expected. Additionally, no individual agile practice
                  exhibited strong growth trends. We also found that
                  while development practices of teams may be similar,
                  some perceive and declare themselves to be following
                  an agile methodology while others do not. Both agile
                  and non-agile practitioners agree on the relative
                  benefits and problem areas of agile
                  techniques. 

                  Conclusions. We found no clear trends in
                  practice adoption. Non-agile practitioners are less
                  enamored of the benefits and more strongly in
                  agreement with the problem areas. The ability for
                  agile practices to be used by large-scale teams
                  generally concerned all respondents, which may limit
                  its future adoption.}, 
 keywords={DP industry;software development management;software prototyping;team working;Microsoft;agile adoption;agile methodology;agile practice;agile techniques;changing attitudes;customer requirements;development practices;high-quality valuable software products;large-scale teams;market pressure;silver bullet;software development organizations;software industry;technical change;Companies;Industries;Interviews;Market research;Software;Testing;Agile;Agile development;Interviews;Survey}, 
 doi={10.1109/ESEM.2013.21}, 
 ISSN={1938-6451},
 topicCode = {agile hase},
 localurl={papers/agile-trends-esem13.pdf}

}

@ARTICLE{6401112, 
 author={Begel, Andrew and Bosch, Jan and Storey, Margaret-Anne}, 
 journal={IEEE Software}, 
 title={Bridging Software Communities through Social Networking: Special Issue}, 
 year={2013}, 
 month={January}, 
 yearMonth={2013-01},
 volume={30}, 
 number={1}, 
 pages={26-28}, 
 abstract={Over the past decade, the advent of social networking has
                  fundamentally altered the landscape of how software
                  is used, designed, and developed. It has expanded
                  how communities of software stakeholders
                  communicate, collaborate, learn from, and coordinate
                  with one another. The guest editors of this special
                  issue describe both the field and the articles they
                  selected for it.}, 
 keywords={social networking (online);software engineering;social networking;software communities;software stakeholders;Social network services;Software development;Software engineering;Special issues and sections;communication;communities;social networking;software;stakeholders}, 
 doi={10.1109/MS.2013.3}, 
 ISSN={0740-7459},
 topicCode = {hase socialmedia},
}

@INPROCEEDINGS{6614736, 
 author={Sillito, Jonathan and Begel, Andrew}, 
 booktitle={Proceedings of 6th International Workshop on Cooperative and Human Aspects of Software Engineering}, 
 title={App-Directed Learning: An Exploratory Study}, 
 year={2013}, 
 month={May}, 
 location={San Francisco, California},
 yearMonth={2013-05},
 pages={81-84}, 
 abstract={Learning a new platform is a common, yet difficult task for
                  software developers today. A range of resources,
                  both official resources (i.e., those provided by the
                  platform owner) and those provided by the wider
                  developer community are available to help
                  developers. To increase our understanding of the
                  learning process and the resources developers use,
                  we conducted an interview and diary study in which
                  ten developers told us about their experience
                  learning to develop Windows Phone applications. We
                  report on a preliminary analysis of our data viewed
                  through the lens of self-directed learning. Using
                  this lens, we characterize the learning strategies
                  of our subjects as app-directed, and describe some
                  of the particular challenges our subjects faced due
                  to this strategy.}, 
 keywords={learning (artificial intelligence);software engineering;Windows phone applications;app-directed learning;official resources;platform owner;resources developers;self-directed learning;software developers;Blogs;Communities;Context;Documentation;Encoding;Interviews;Software}, 
 doi={10.1109/CHASE.2013.6614736},
 topicCode = {csed hase},
 localurl={papers/appdirectedlearning-chase2013.pdf}

}

@INPROCEEDINGS{6405317, 
 author={Guzzi, Anja and Begel, Andrew and Miller, Jessica K. and Nareddy, Krishna}, 
 booktitle={Proceedings of 28th IEEE International Conference on Software Maintenance}, 
 title={Facilitating Enterprise Software Developer Communication with CARES}, 
 year={2012}, 
 month={September}, 
 yearMonth={2012-09},
 pages={527-536}, 
 location={Riva del Garda, Italy},
 abstract={Enterprise software developers must regularly communicate
                  with one another to obtain information and
                  coordinate changes to legacy code, but find it
                  cumbersome and complicated to determine the most
                  relevant and expedient person to contact. This
                  becomes especially difficult when the relevant
                  person has transferred teams or changed their
                  personal contact information since contributing to
                  the project. We conducted a year-long series of
                  surveys and interviews to help us learn how, why,
                  and how often software developers discover and
                  communicate with one another. In response to what we
                  saw, we designed, deployed, and evaluated a
                  domain-specific, IDE-embedded, photo-oriented,
                  communication tool. We overcame a significant
                  challenge found in long-lived projects: uniquely
                  identifying individuals years after their
                  contributions to the project. After deploying our
                  tool, iteratively refining it, and deploying it
                  again on a company-wide scale, most users reported
                  that it simplified the process of finding and
                  reaching out to other developers and offered them a
                  sense of community with their colleagues, even if
                  those colleagues did not currently work on their
                  team. The lessons learned from our study and tool
                  development should apply to other large, multi-team,
                  legacy software projects.}, 
 keywords={personal information systems;software maintenance;team working;CARES framework;domain-specific IDE-embedded photo-oriented communication tool;enterprise software developer communication facilitation;large-multiteam legacy software code projects;personal contact information;Conferences;Electronic mail;Inteviews;Software maintenance;USA Councils;Visualization;communication;coordination;longitudinal empirical study;software engineering}, 
 doi={10.1109/ICSM.2012.6405317}, 
 ISSN={1063-6773},
 topicCode = {hase tool},
 localurl={papers/CARES-ICSMindustry.pdf}

}

@inproceedings{liblit2006cognitive,
  title={Cognitive Perspectives on the Role of Naming in Computer Programs},
  author={Liblit, Ben and Begel, Andrew and Sweetser, Eve},
  booktitle={Proceedings of the 18th Annual Psychology of Programming Workshop},
  year={2006},
  month={September},
 yearMonth={2006-09},
 location={Brighton, England, United Kingdom},
 topicCode={hase},
 localurl={papers/ppig-naming.pdf},
abstract={Programming a computer is a complex, cognitively rich
                  process. This paper examines ways in which human
                  cognition is reflected in the text of computer
                  programs. We concentrate on naming: the assignment
                  of identifying labels to programmatic
                  constructs. Naming is arbitrary, yet programmers do
                  not select names arbitrarily. Rather, programmers
                  choose and use names in regular, systematic ways
                  that reflect deep cognitive and linguistic
                  influences. This, in turn, allows names to carry
                  semantic cues that aid in program understanding and
                  support the larger software development process.}
}

@inproceedings{begel2005programming,
  title={Programming by Voice: A Domain-Specific Application of Speech Recognition},
  author={Begel, Andrew},
  booktitle={Proceedings of AVIOS Speech Technology Symposium - SpeechTek West},
  year={2005},
  month={March},
  yearMonth={2005-03},
  location={San Francisco, California},
  topicCode={hase proglang},
 localurl={papers/begel-speechtek2005.pdf},
abstract={Programming environments can create frustrating barriers for
                  the growing numbers of software developers that
                  suffer from repetitive strain injuries (RSI) and
                  related disabilities that make typing difficult or
                  impossible. Not only is the software development
                  process comprised of fairly text-intensive
                  activities like program composition, editing and
                  navigation, but the tools used for programming are
                  also operated textually. This results in a work
                  environment for programmers in which long hours of
                  RSI-exacerbating typing are unavoidable.}
}

@article{2104852720060801,
abstract = {Automatically generated lexers and parsers for programming
                  languages have a long history. Although they are
                  well suited for many languages, many widely used
                  generators, among them Flex and Bison, fail to
                  handle input stream ambiguities that arise in
                  embedded languages, in legacy languages, and in
                  programming by voice. We have developed Blender, a
                  combined lexer and parser generator that enables
                  designers to describe many classes of embedded
                  languages and to handle ambiguities in spoken input
                  and in legacy languages. We have enhanced the
                  incremental lexing and parsing algorithms in our
                  Harmonia framework to analyse lexical, syntactic and
                  semantic ambiguities. The combination of better
                  language description and enhanced analysis provides
                  a powerful platform on which to build the next
                  generation of language analysis tools.},
author = {Begel, Andrew and Graham, Susan L.},
ISSN = {01676423},
journal = {Science of Computer Programming},
keywords = {ALGORITHMS, PROGRAMMING languages (Electronic computers), ALGEBRA, MATHEMATICAL analysis},
number = {3},
pages = {211-227},
title = {XGLR - An Algorithm for Ambiguity in Programming Languages.},
volume = {61},
doi={10.1016/j.scico.2006.04.003},
year = {2006},
month={August},
yearMonth={2006-08}
topicCode={proglang},
}

@article{Begel200475,
title = "Language Analysis and Tools for Ambiguous Input Streams",
journal = "Electronic Notes in Theoretical Computer Science",
volume = "110",
number = "0",
pages = "75-96",
year = "2004",
note = "Proceedings of the Fourth Workshop on Language Descriptions, Tools, and Applications",
issn = "1571-0661",
doi = "10.1016/j.entcs.2004.06.009",
url = "http://www.sciencedirect.com/science/article/pii/S157106610405220X",
author = "Begel, Andrew and Graham, Susan L.",
keywords = "\{GLR\}",
keywords = "embedded languages",
keywords = "Harmonia",
keywords = "programming-by-voice ",
abstract = "Automatically generated lexers and parsers for programming
                  languages have a long history. Although they are
                  well-suited for many languages, many widely-used
                  generators, among them Flex and Bison, fail to
                  handle input stream ambiguities that arise in
                  embedded languages, in legacy languages, and in
                  programming by voice. We have developed Blender, a
                  combined lexer and parser generator that enables
                  designers to describe many classes of embedded
                  languages and to handle ambiguities in spoken input
                  and in legacy languages. We have enhanced the
                  incremental lexing and parsing algorithms in our
                  Harmonia framework to analyze lexical, syntactic and
                  semantic ambiguities. The combination of better
                  language description and enhanced analysis provides
                  a powerful platform on which to build the next
                  generation of language analysis tools. ",
 topicCode={proglang},
 month={December},
 yearMonth={2004-12},
 localurl={papers/begel-ambig.pdf}

}

@article{DBLP:journals.concurrency.BegelBCG02,
  author    = {Begel, Andrew and Buonadonna, Philip and Culler, David E. and Gay, David},
  title     = {An Analysis of {VI} Architecture Primitives in Support of Parallel
               and Distributed Communication},
  journal   = {Concurrency and Computation: Practice and Experience},
  year      = {2002},
  volume    = {14},
  number    = {1},
  pages     = {55-76},
  doi       = {10.1002/cpe.616},
  biburl    = {http://dblp.uni-trier.de/rec/bib/journals/concurrency/BegelBCG02},
  bibsource = {dblp computer science bibliography, http://dblp.org},
  topicCode={proglang},
  month={January},
  yearMonth={2002-01},
 localurl={split-c.pdf},
abstract={We present the results of a detailed study of the Virtual
                  Interface (VI) paradigm as a communication
                  foundation for a distributed computing
                  environment. Using Active Messages and the Split-C
                  global memory model, we analyze the inherent costs
                  of using VI primitives to implement these highlevel
                  communication abstractions. We demonstrate a minimum
                  mapping cost (i.e. the host processing required to
                  map one abstraction to a lower abstraction) of 5.4
                  $\micro$sec for both Active Messages and Split-C
                  using 4-way 550 MHz Pentium III SMPs and the Myrinet
                  network. We break down this cost to use of
                  individual VI primitives in supporting flow control,
                  buffer management and event processing and identify
                  the completion queue as the source of the highest
                  overhead.  Bulk transfer performance plateaus at 44
                  Mbytes/sec for both implementations due to the
                  addition of fragmentation requirements. Based on
                  this analysis, we present the implications for the
                  VI successor, Infiniband.}
}

@article{klopfer2005starlogo,
  title={StarLogo TNG. An introduction to game development},
  author={Klopfer, Eric and Begel, Andrew},
  journal={Journal of E-Learning},
  year={2005},
  yearMonth={2005},
  topicCode={csed proglang},
 localurl={papers/starlogo-tng.pdf},
abstract={The science of developing computer programs offers a rich
                  educational experience that can help students gain
                  fluency with information technology. Unfortunately,
                  while computers have become commonplace in schools,
                  the practice of teaching programming is being
                  squeezed out of high school and middle school
                  curricula. We believe that programming should be
                  reintroduced to students, and that this can be done
                  by focusing on video game construction, a compelling
                  subject area for many students. Given the current
                  expertise required to create a modern video game,
                  new tools are needed to make this experience
                  accessible to students. We have developed StarLogo
                  TNG, a visual programming- and 3Dbased environment
                  that enables students to easily program their own
                  games. It uses graphical programming to ease the
                  learning curve for programming, and 3D graphics to
                  make the developed games more realistic. An initial
                  pilot study has shown that these innovations appeal
                  to students, and in particular appeal to girls.}
}

@inbook{begel2005starlogo,
  title={StarLogo: A Programmable Complex Systems Modeling Environment for Students and Teachers},
  editor={Komosinski, Maciej and Adamatzky, Andrew},
  author={Begel, Andrew and Klopfer, Eric},
  booktitle={Artificial Life Models in Software},
  pages={187-209},
  chapter={8},
  year={2005},
  publisher={Springer}, 
  yearMonth={2005-01},
  topicCode={csed proglang},
  url={http://www.amazon.com/Artificial-Models-Software-Andrew-Adamatzky/dp/1852339454},
}


@article{klopfer2003starlogo,
  title={StarLogo under the Hood and in the Classroom},
  author={Klopfer, Eric and Begel, Andrew},
  journal={Kybernetes},
  volume={32},
  number={1/2},
  pages={15-37},
  year={2003},
  month={January},
  publisher={MCB UP Ltd},
  yearMonth={2003-01},
  topicCode={csed proglang},
 localurl={starlogo/starlogo-kybernetes-paper.pdf},
 abstract={StarLogo is a computer modeling tool that empowers students
                  to understand the world through the design and
                  creation of complex systems models. StarLogo enables
                  students to program software creatures to interact
                  with one another and their environment, and study
                  the emergent patterns from these
                  interactions. Building an easy-to-understand, yet
                  powerful tool for students required a great deal of
                  thought about the design of the programming
                  language, environment, and its implementation. The
                  salient features are StarLogo's great degree of
                  transparency (the capability to see how a simulation
                  is built), its support to let students create their
                  own models (not just use models built by others),
                  its efficient implementation (supporting simulations
                  with thousands of independently executing creatures
                  on desktop computers), and its flexible and simple
                  user interface (which enables students to interact
                  dynamically with their simulation during model
                  testing and validation). The resulting platform
                  provides a uniquely accessible tool that enables
                  students to become full-fledged practitioners of
                  modeling. In addition, we describe the powerful
                  insights and deep scientific understanding that
                  students have developed through the use of
                  StarLogo.}
}

@inproceedings{begel2007codifier,
  title={Codifier: A Programmer-Centric Search User Interface},
  author={Begel, Andrew},
  booktitle = {Proceedings of Workshop on Human-Computer Interaction and Information Retrieval},
  month={October}, 
  year={2007},
  yearMonth={2007-10},
  location={Cambridge, Massachusetts},
  topicCode={hase tool},
  pages={23-24},
 localurl={papers/Codifier.pdf},
 abstract={Search tools have transformed knowledge discovery by
                  exposing information from previously hidden
                  re-positories to the workers who need it. Search
                  engines like Google and Live.com provide search
                  capabilities via a simple one-line text query box,
                  and present results in a paged HTML list. When the
                  repository be-ing searched contains structured
                  information with extractable metadata (e.g. program
                  source code), it can be advantageous to index the
                  metadata and use it to enable queries that are more
                  task-centric and suitable for an domain-specific
                  audience. Codifier is a programmer-centric search
                  user interface that enables software developers to
                  ask domain-specific questions related to programming
                  languages and software.}
}

@inbook{oram2010making,
  title ={Novice Professional: Recent Graduates in a First Software Engineering Job},
  booktitle={Making software: what really works, and why we believe it},
  editor={Oram, Andy and Wilson, Greg},
  author={Begel, Andrew and Simon, Beth},
  year={2010},
  publisher={"O'Reilly Media"},
  month={October},
  yearMonth={2010-10},
  topicCode={hase csed},
 url={http://www.amazon.com/Making-Software-Really-Works-Believe/dp/0596808321/ref=tmm_pap_title_0},
abstract={Much is written about software engineering education - how
                  to teach novice computer scientists the programming,
                  design and testing skills they need to become
                  professional software engineers. However, computer
                  science students are not done with their education
                  at graduation; it is really just the
                  beginning. Newly hired engineers must learn to edit,
                  debug, and create code on a deadline while learning
                  to communicate and interact appropriately with a
                  large team of colleagues. In this chapter, we
                  explore the similarities and differences between
                  these two educational experiences, by providing a
                  detailed view of the novice experience of software
                  developers in their first industry job.}
}

@inproceedings{hemphill2008will,
  title={How Will You See My Greatness if You Can't See Me? Poster.},
  author={Hemphill, Libby and Begel, Andrew},
  booktitle={Proceedings of the ACM Conference Computer Supported Cooperative Work},
  year={2008},
  month={November},
  yearMonth={2008-10},
  location={San Diego, California},
  topicCode={hase poster},
 localurl={papers/cscw-greatness08.pdf},
abstract={Newly hired employees go through a ramp-up period of
                  acclimating to their organization. This period,
                  known as on- boarding, is often stressful and
                  challenging for both the new hires and their
                  managers. In globally distributed software
                  development teams, the onboarding process may also
                  be dis- tributed; new hires may be in completely
                  different locations than their managers and
                  teammates. We are conducting a qualitative study of
                  new hires who work remotely from their software
                  development teams. Our data indicate that these new
                  hires are impacted by their struggle to get noticed
                  by their managers and teams during their first few
                  weeks on the job. In this poster, we offer evidence
                  that remote new hires are frustrated by their
                  diminished opportunities to demonstrate proficiency
                  to their managers and are un- able to observe some
                  important kinds of great work by their teammates.}
}

@InProceedings{begel-sslsd,
  author = 	 {Begel, Andrew},
  title = 	 {Help, I Need Somebody! Poster.}, 
  booktitle = {Proceedings of Workshop on Supporting the Social Side of Large-Scale Software Development},
  year =	 {2006},
  month =	 {November},
  location =	 {Banff, Alberta, Canada},
  yearMonth={2006-11},
  topicCode={hase poster},
 localurl={papers/cscw-help06.pdf},
abstract={Information discovery is a very difficult and frustrating
                  aspect of software development. Novice developers
                  are often assigned a mentor who preemptively
                  provides answers and advice without requiring the
                  novice to explicitly ask for help. A similar
                  situation occurs among expert developers in
                  radically collocated settings. The close proximity
                  enhances communication between all members of a
                  group, providing needed information, often
                  preemptively due to ambient awareness of other
                  developers. In this paper, we propose a mechanism to
                  extend this desirable property of preemptive
                  mentoring to developers in more traditional software
                  engineering environments. The proposed system will
                  infer when and how a developer becomes blocked
                  looking for information, and notify an appropriate
                  expert to come to his aid. We believe that this
                  preemptive help will lower developer frustration and
                  enhance diffusion of expert knowledge throughout an
                  organization.}
}

@Proceedings{begel-harmonia,
  author={Graham, Susan L. and Begel, Andrew and Boshernitsan, Marat},
  title = 	 {Eclipse + Harmonia: Language-Based Tools for the Programmer. Poster.},
  year = 	 {2003},
  booktitle =	 {Proceedings of Workshop on Eclipse Technology Exchange},
  month =	 {October},
  yearMonth={2003-10},
  location={Anaheim, California},
  topicCode={proglang tool poster},
 localurl={harmonia/harmonia-oopsla-2003-poster.pdf},
abstract={Harmonia: An extensible framework for interactive, language-aware programming tools.}

}



@TechReport{hemphill-notseen,
  author = 	 {Hemphill, Libby and Begel, Andrew},
  title = 	 {Not Seen and Not Heard: Onboarding Challenges in Newly Virtual Team},
  institution =  {Microsoft Research},
  year = 	 {2009},
  number =	 {MSR-TR-2009-135},
  month =	 {September},
  yearMonth={2009-09},
  topicCode={hase},
  location={Redmond, Washington},
 localurl={papers/notseen-notheard-msrtr11.pdf},
abstract={Virtual teams, in which the members work from multiple
                  locations, have become a common feature at many
                  global organizations. In spite of this new reality,
                  collocated teams experience difficulties in adapting
                  their established processes and practices for a
                  newly virtual working environment, greatly impeding
                  their performance, productivity, and morale. In this
                  paper, we present findings from a qualitative case
                  study of five software teams that hired and
                  onboarded their first remote team member. Our
                  analyses focus on three underappreciated aspects of
                  the virtual onboarding process: trying to learn team
                  practices as the team changes them, building and
                  maintaining social relationships with physically
                  remote teammates, and evaluating and managing
                  expectations of performance from afar. From the
                  results of our analyses, we pose seven propositions
                  about virtual onboarding that should be explored in
                  future studies.}
}


@TechReport{begel-transform,
  author = 	 {Begel, Andrew and Boshernitsan, Marat and Graham, Susan L.},
  title = 	 {Transformational Generation of Language Plug-ins in the Harmonia Framework},
  institution =  {University of California at Berkeley},
  year = 	 {2005},
  number =	 {CSD-05-1370},
  location = 	 {Berkeley, California},
  month =	 {January},
  yearMonth={2005-01},
  topicCode={proglang},
 localurl={papers/csd-05-1370.pdf},
abstract={The Harmonia framework provides an infrastructure for
                  building language-aware interactive programming
                  tools. Harmonia supports many languages through
                  language plug-ins, which are dynamically-loadable
                  system extensions generated from lexical, syntactic,
                  and semantic descriptions. In this report, we
                  describe our approach to generating Harmonia
                  language plug-ins from a variety of domain-specific
                  description languages. We present the process of
                  configuring plug-in analysis components, the
                  transformations for high-level syntactic and
                  semantic descriptions, and the optimizations for
                  generated code. This largely adhoc process makes our
                  generation techniques expensive to create and
                  difficult to maintain. We propose a new
                  component-based architecture based on
                  transformational generation, present its benefits,
                  and outline several research directions that still
                  need to be addressed by the generative programming
                  community.}
}

@InProceedings{begel-enduser,
author={Begel, Andrew},  
title = 	 {End User Programming for Scientists: Modeling Complex Systems},
  year = 	 {2007},
  booktitle =	 {Dagstuhl Seminary Proceedings on End-User Software Engineering},
  location =	 {Dagstuhl, Germany},
  month =	 {February},
yearMonth={2007-02},
 topicCode={hase},
 localurl={papers/dagstuhl-enduserscience07.pdf},
abstract={Towards the end of the 20th century, a paradigm shift took
                  place in many scientific labs. Scientists embarked
                  on a new form of scientific inquiry seeking to
                  understand the behavior of complex adaptive systems
                  that increasingly defied traditional reductive
                  analysis. By combining experimental methodology with
                  computer-based simulation tools, scientists gain
                  greater understanding of the behavior of systems
                  such as forest ecologies, global economies, climate
                  modeling, and beach erosion. This improved
                  understanding is already being used to influence
                  policy in critical areas that will affect our
                  nation's future, and the world's.}
}



@Proceedings{begel-dc2002,
  author={Begel, Andrew},
  title = 	 {Spoken Language Support for Software Development},
  year = 	 {2002},
  booktitle =	 {Proceedings of the Doctoral Consortium of the 33rd SIGCSE Technical Symposium on Computer Science Education},
  location =	 {Covington, Kentucky},
  month =	 {March},
  yearMonth={2002-03},
  topicCode={proglang},
 localurl={harmonia/begel-sigcse02.pptx},
abstract={Software development environments have changed little since
                  their origins as low-level text editors. Programmers
                  with repetitive strain injuries and other motor
                  disabilities can find these environments difficult
                  or impossible to use due to their emphasis on
                  typing. Our research adapts voice recognition to the
                  software development process, both to mitigate this
                  difficulty and to provide insight into natural forms
                  of high-level interaction. Our contribution is to
                  use program analysis to interpret speech as code,
                  thereby enabling the creation of a program editor
                  that supports voice-based programming. We have
                  created Spoken Java, a variant of Java which is
                  easier to verbalize than its traditional typewritten
                  form, and an associated spoken command language to
                  manipulate code. We are conducting user studies to
                  understand the cognitive effects of spoken
                  programming, as well as to inform the design of the
                  language and editor. 
}

@PhdThesis{begel-phd-thesis,
  author = 	 {Begel, Andrew},
  title = 	 {Spoken Language Support for Software Development},
  school = 	 {University of California at Berkeley},
  year = 	 {2005},
  location = 	 {Berkeley, California},
  month =	 {December},
yearMonth={2005-12},
  number={EECS-2006-8},
  topicCode={hase proglang dissertations},
 localurl={begel-phd-thesis.pdf},
abstract={Programmers who suffer from repetitive stress injuries find
                  it difficult to program by typing. Speech interfaces
                  can reduce the amount of typing, but existing
                  programming-by-voice techniques make it awkward for
                  programmers to enter and edit program text. We used
                  a human-centric approach to address these
                  problems. We first studied how programmers verbalize
                  code, and found that spoken programs contain
                  lexical, syntactic and semantic ambiguities that do
                  not appear in written programs. Using the results
                  from this study, we designed Spoken Java, a
                  semantically identical variant of Java that is
                  easier to speak. Inspired by a study of how voice
                  recognition users navigate through documents, we
                  developed a novel program navigation technique that
                  can quickly take a software developer to a desired
                  program position.  

                  Spoken Java is analyzed by
                  extending a conventional Java programming language
                  analysis engine written in our Harmonia program
                  analysis framework. Our new XGLR parsing framework
                  extends GLR parsing to process the input stream
                  ambiguities that arise from spoken programs (and
                  from embedded languages). XGLR parses Spoken Java
                  utterances into their many possible
                  interpretations. To semantically analyze these
                  interpretations and discover which ones are legal,
                  we implemented and extended the Inheritance Graph, a
                  semantic analysis formalism which supports
                  constant-time access to type and use-definition
                  information for all names defined in a program. The
                  legal interpretations are the ones most likely to be
                  correct, and can be presented to the programmer for
                  confirmation.  

                  We built an Eclipse IDE plugin called
                  SPEED (for SPEech EDitor) to support the combination
                  of Spoken Java, an associated command language, and
                  a structure-based editing model called
                  Shorthand. Our evaluation of this software with
                  expert Java developers showed that most developers
                  had little trouble learning to use the system, but
                  found it slower than typing.  

                  Although
                  programming-by-voice is still in its infancy, it has
                  already proved to be a viable alternative to typing
                  for those who rely on voice recognition to use a
                  computer. In addition, by providing an alternative
                  means of programming a computer, we can learn more
                  about how programmers communicate about code.}
}


@MastersThesis{begel-masters-thesis,
  author = 	 {Begel, Andrew},
  title = 	 {Bongo: A Kids' Programming Environment for Creating Video Games on the Web},
  school = 	 {Massachusetts Institute of Technology},
  year = 	 {1997},
  location =	 {Cambridge, Massachusetts},
  month =	 {June},
  yearMonth={1997-06},
  topicCode={csed proglang dissertations},
 localurl={mit/begel-meng-thesis.pdf},
abstract={In recent years, a growing number of researchers and
                  educators have argued that design projects provide
                  rich opportunities for learning. To support this
                  type of learning, educational researchers have
                  developed computational environments (such as Logo
                  and LEGO/Logo) that enable children to design their
                  own animated stories, simulations, and even robotic
                  constructions. The rise of the Internet presents an
                  opportunity for new types of design activities,
                  enabling kids to create projects that reach a larger
                  audience than ever before. Some kids are beginning
                  to create their own home pages on the World Wide
                  Web.  With the Java programming language, people can
                  now create increasingly sophisticated Web pages with
                  dynamic, interactive content. But Java is intended
                  for expert programmers, not children. This thesis
                  describes a new programming language and environment
                  called Bongo that brings the power of Java to
                  kids. In particular, it discusses a construction kit
                  written in Bongo that enables kids to build their
                  own video games, and to share those games with
                  others on the Web.}
}


@MastersThesis{begel-bachelors-thesis,
  author = 	 {Begel, Andrew},
  title = 	 {LogoBlocks: A Graphical Programming Language for Interacting with the World},
  school = 	 {Massachusetts Institute of Technology},
  year = 	 {1996},
  location =	 {Cambridge, Massachusetts},
  month =	 {June},
  yearMonth={1996-06},
  topicCode={csed proglang dissertations},
 localurl={mit/begel-aup.pdf},
abstract={LogoBlocks is a graphical programming language for the
                  Programmable Brick, developed at the Epistemology
                  and Learning Group in the MIT Media Lab. The
                  Programmable Brick is a small handheld computer that
                  a person can attach to a LEGO creation to control
                  motors and read inputs from sensors. LogoBlocks is
                  intended to be an alternative language to BrickLogo,
                  which is a variant of Logo developed for use with
                  the Programmable Brick.  Graphical programming has
                  some significant advantages over textual programming
                  especially in providing visual cues for younger
                  programmers. LogoBlocks attempts to concretize some
                  of these ideas and make the process of building
                  active LEGO creations easier and more intuitive for
                  young children.}
}

@Proceedings{deline-summer,
  title = 	 {UW/MSR Summer Institute on the Human Side of Software Development},
  year = 	 {2007},
  editor =	 {DeLine, Robert and Venolia, Gina and Begel, Andrew and Notkin, David and Hendry, David},
  location =	 {Stevenson, Washington},
  month =	 {August},
 yearMonth={2007-08},
 topicCode={workshop hase},
 url={http://www.cs.washington.edu/mssi/2007/index.html},
abstract={Each summer, the University of Washington and Microsoft
                  Research jointly host a workshop on a
                  cross-disciplinary topic to bring together
                  researchers who share a common interest but would
                  not likely meet one another in their normal
                  travels. You can find a description of past summer
                  institutes at: http://www.cs.washington.edu/mssi/. This year's
                  workshop focuses on software development as a human
                  activity for individuals, teams and
                  organizations. The workshop will bring together
                  roughly 50 participants from academia, industry and
                  government who bring perspectives from diverse
                  disciplines, including software engineering,
                  human-computer interaction, computer-supported
                  collaborative work, psychology, and organizational
                  behavior. Because existing research in this area is
                  so wide-spread, our main goal is community
                  building. We hope this workshop will form a large
                  step toward establishing this problem area as an
                  established field of research. The meeting will
                  include presentations, including keynotes from each
                  field, panels and breakout sessions, with planned
                  flexibility to allow us to tailor to the
                  participants' goals.}
}


@proceedings{Begel:2006:KLC,
 author = {Begel, Andrew and Bates, Rebecca and Wolfman, Steven A.},
 title = {Kinesthetic Learning in the Classroom},
 year = {2006},
 month={March},
 yearMonth={2006-03},
 location = {Dallas, Texas},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Kinesthetic learning style, active learning, sensorimotor learning},
 topicCode = {workshop csed},
 url={http://www.cs.ubc.ca/~kla/}

} 

@proceedings{Begel:2005:KLC,
 author = {Begel, Andrew and Garcia, Daniel D. and Wolfman, Steven A.},
 title = {Kinesthetic Learning in the Classroom},
 year = {2005},
 month={March},
 yearMonth={2005-03},
 location = {St. Louis, Missouri},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Kinesthetic learning style, active learning, sensorimotor learning},
 topicCode = {workshop csed},
 url={http://www.cs.ubc.ca/~kla/}

} 
@proceedings{Begel:2005:csit:june:KLC,
 author = {Begel, Andrew},
 title = {Kinesthetic Learning in the Classroom},
 year = {2005},
 month={June},
 yearMonth={2005-06},
 location = {Philadelphia, Pennsylvania},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Kinesthetic learning style, active learning, sensorimotor learning},
 topicCode = {workshop csed},
 url={http://www.cs.ubc.ca/~kla/}

} 

@proceedings{Begel:2005:csit:feb:KLC,
 author = {Begel, Andrew},
 title = {Kinesthetic Learning in the Classroom},
 year = {2005},
 month={February},
 yearMonth={2005-02},
 location = {St. Louis, Missouri},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Kinesthetic learning style, active learning, sensorimotor learning},
 topicCode = {workshop csed},
 url={http://www.cs.ubc.ca/~kla/}

} 

@article{roy2016guest,
  title={Guest editor's introduction to the Special Issue on Program Comprehension (ICPC 2014)},
  author={Roy, Chanchal K and Begel, Andrew and Moonen, Leon},
  journal={Journal of Software: Evolution and Process},
  volume={28},
  number={10},
  yearMonth={2016-10},
  topicCode={proglang},
  pages={838--839},
  year={2016}
}

@inproceedings{begel-icgse16,
  title={Keynote Talk: The ABCs of Software Engineering: Affect, Biometrics, and Cognition},
  author={Begel, Andrew},
  booktitle={Global Software Engineering (ICGSE), 2016 IEEE 11th International Conference on},
  pages={xviii--xx},
  year={2016},
  yearMonth={2016-08},
  month={August},
  topicCode={gsd biometrics talk},
  organization={IEEE},
  abstract={Researchers have long investigated how people read, write, and speak about software on their computers to identify the skills, education, and practices needed need to acquire expertise and perform development duties effectively and efficiently. However, until now the methods used to study developer comprehension, expression, and communication have been limited and coarse-grained because there was no way to identify what a developer thought or felt unless it was expressed out loud.

The world has changed. With the introduction of low-cost, widely available, high-fidelity biometric sensors, we can now more directly observe a software developer's cognitive and affective (emotional) processes. The ABCs of Software Engineering is a set of techniques that modernize classic approaches to program comprehension and human interaction by combining (A) principles governing the influence of human *affect* on behavior, (B) *biometric* sensors, and (C) models of *cognition* informed by advances in cognitive neuroscience. Technologies like electroencephalography (EEG), electro-dermal activity sensors (EDA), capacitive sensors, and eye trackers can reveal a software developer's internal emotional states, for example identifying when the developer is confused, frustrated, surprised, stressed, fatigued, or in a highly productive flow state. These affective states can be correlated with code quality, software complexity, development productivity, and effective communication --- the same software outcomes already correlated with developer activities in other research areas such as mining software repositories (MSR) and cooperative and human aspects of software engineering (CHASE). By developing a better understanding of what programmers think and feel when they create and maintain software, we can design tools and interventions to improve their productivity and reduce the impact of their errors.},
}


@inproceedings{begel-profes2018,
  title={Keynote Talk: The Hitchhikerâ€™s Guide to Engineering AI-Infused Applications},
  author={Begel, Andrew},
  booktitle={19th International Conference on Product-Focused Software Process Improvement},
  pages={1--1},
  year={2018},
  yearMonth={2016-11},
  month={November},
  topicCode={hase talk},
  abstract={Artificial intelligence and machine learning (AI/ML) are some of the newest trends to hit the software industry, compelling organizations to evolve their development processes to deliver novel products to their customers. In this talk, I will describe how Microsoft software teams develop AI/ML-based applications using a nine-stage AI workflow process informed by prior experiences developing early AI applications (e.g. search and NLP) and data science tools (e.g. application telemetry and bug reporting). Adapting this workflow into their pre-existing, well-evolved, Agile-like software engineering processes and job roles has resulted in a number of engineering challenges unique to the AI/ML domain, some universal to all teams, but others related to the amount of prior AI/ML experience and education the teams have. I will tell you about some challenges and the solutions that teams have come up with.

I believe there are three challenges in the AI/ML domain that make it fundamentally different from prior software engineering application domains:

Discovering, managing, and versioning the data needed to power AI/ML is much more complex and difficult than other types of software engineering,
AI/ML model customization and reuse practices require very different skills than are typically found in software teams, and
AI components do not modularize like software components â€” models may be â€œentangledâ€ in complex ways and experience non-monotonic error behavior.
The lessons that Microsoft has learned can help other organizations embarking on their own path towards AI and ML.},
}
